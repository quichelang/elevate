use std::fs;
use std::process::Command;
use std::time::{SystemTime, UNIX_EPOCH};

fn bin() -> &'static str {
    env!("CARGO_BIN_EXE_elevate")
}

#[test]
fn cli_emits_rust_to_stdout() {
    let root = temp_dir("elevate-cli-stdout");
    let src = root.join("input.ers");
    fs::write(&src, "fn id(v: i64) -> i64 { v }\n").expect("write source should succeed");

    let output = Command::new(bin())
        .arg(&src)
        .output()
        .expect("run cli should succeed");
    assert!(output.status.success());
    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("// Generated by elevate compiler."));
    assert!(stdout.contains("fn id(v: i64) -> i64"));
}

#[test]
fn cli_emits_rust_to_file() {
    let root = temp_dir("elevate-cli-file");
    let src = root.join("input.ers");
    let out = root.join("out.rs");
    fs::write(&src, "fn id(v: i64) -> i64 { v }\n").expect("write source should succeed");

    let output = Command::new(bin())
        .arg(&src)
        .arg("--emit-rust")
        .arg(&out)
        .output()
        .expect("run cli should succeed");
    assert!(output.status.success());
    let rendered = fs::read_to_string(&out).expect("output file should exist");
    assert!(rendered.contains("fn id(v: i64) -> i64"));
}

#[test]
fn cli_test_runs_discovered_test_prefixed_functions() {
    let root = temp_dir("elevate-cli-test");
    fs::create_dir_all(root.join("src")).expect("create src should succeed");
    fs::write(
        root.join("Cargo.toml"),
        "[package]\nname = \"mini\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[lib]\nname = \"mini\"\npath = \"src/lib.rs\"\n",
    )
    .expect("write manifest should succeed");
    fs::write(
        root.join("src/lib.ers"),
        "fn test_truth() {\n    assert_eq(2 + 2, 4);\n}\n",
    )
    .expect("write source should succeed");

    let output = Command::new(bin())
        .arg("test")
        .arg(&root)
        .output()
        .expect("run cli should succeed");
    assert!(output.status.success());
    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("discovered 1 test(s)"));
}

#[test]
fn cli_accepts_experiment_flags_for_compile() {
    let root = temp_dir("elevate-cli-exp");
    let src = root.join("input.ers");
    fs::write(&src, "fn id(v: i64) -> i64 { v }\n").expect("write source should succeed");

    let output = Command::new(bin())
        .arg(&src)
        .arg("--exp-infer-local-bidi")
        .output()
        .expect("run cli should succeed");
    assert!(output.status.success());
    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("experimental flag enabled: exp_infer_local_bidi"));
}

#[test]
fn cli_accepts_principal_fallback_flag_for_compile() {
    let root = temp_dir("elevate-cli-exp-fallback");
    let src = root.join("input.ers");
    fs::write(&src, "fn id(v: i64) -> i64 { v }\n").expect("write source should succeed");

    let output = Command::new(bin())
        .arg(&src)
        .arg("--exp-infer-principal-fallback")
        .output()
        .expect("run cli should succeed");
    assert!(output.status.success());
    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("experimental flag enabled: exp_infer_principal_fallback"));
}

#[test]
fn cli_init_scaffolds_transparent_bootstrap_runner() {
    let workspace = temp_dir("elevate-cli-init");
    let root = workspace.join("starter");

    let output = Command::new(bin())
        .arg("init")
        .arg(&root)
        .arg("--name")
        .arg("starter")
        .arg("--vcs")
        .arg("none")
        .arg("--bin")
        .output()
        .expect("run cli init should succeed");
    assert!(output.status.success());

    let manifest =
        fs::read_to_string(root.join("Cargo.toml")).expect("manifest should exist after init");
    assert!(manifest.contains("[[bin]]"));
    assert!(manifest.contains("path = \"src/main.rs\""));

    let bootstrap =
        fs::read_to_string(root.join("src/main.rs")).expect("bootstrap runner should exist");
    assert!(bootstrap.contains("elevate build"));
    assert!(bootstrap.contains("elevate-gen"));
    assert!(bootstrap.contains("--manifest-path"));
    assert!(bootstrap.contains("arg == \"build\" || arg == \"run\""));
    assert!(bootstrap.contains("build_flag_takes_value"));
    assert!(bootstrap.contains("if invocation.build_only"));

    let main_ers =
        fs::read_to_string(root.join("src/main.ers")).expect("main.ers should exist after init");
    assert!(main_ers.contains("fn main()"));
}

#[test]
fn cli_bootstrap_build_forwards_experiment_and_value_flags() {
    let workspace = temp_dir("elevate-cli-bootstrap-build");
    let root = workspace.join("starter");
    init_bin_project(&root);

    let log = workspace.join("elevate.log");
    let fake_bin = workspace.join("fake-bin");
    fs::create_dir_all(&fake_bin).expect("fake-bin should be created");
    install_fake_command(&fake_bin, "elevate", &log, true);

    let bootstrap_bin = build_bootstrap_binary(&root, "starter");
    let output = Command::new(&bootstrap_bin)
        .arg("build")
        .arg(&root)
        .arg("--exp-infer-local-bidi")
        .arg("--source-name")
        .arg("runtime.ers")
        .env("PATH", prepend_path(&fake_bin))
        .output()
        .expect("bootstrap should run");
    assert!(output.status.success());

    let logged = fs::read_to_string(&log).expect("fake elevate log should exist");
    assert!(logged.contains("build"));
    assert!(logged.contains("--exp-infer-local-bidi"));
    assert!(logged.contains("--source-name"));
    assert!(logged.contains("runtime.ers"));
}

#[test]
fn cli_bootstrap_run_forwards_build_flags_and_runtime_args() {
    let workspace = temp_dir("elevate-cli-bootstrap-run");
    let root = workspace.join("starter");
    init_bin_project(&root);

    let elevate_log = workspace.join("elevate.log");
    let cargo_log = workspace.join("cargo.log");
    let fake_bin = workspace.join("fake-bin");
    fs::create_dir_all(&fake_bin).expect("fake-bin should be created");
    install_fake_command(&fake_bin, "elevate", &elevate_log, true);
    install_fake_command(&fake_bin, "cargo", &cargo_log, true);

    let bootstrap_bin = build_bootstrap_binary(&root, "starter");
    let output = Command::new(&bootstrap_bin)
        .arg("run")
        .arg(&root)
        .arg("--exp-infer-local-bidi")
        .arg("--")
        .arg("--seed")
        .arg("7")
        .env("PATH", prepend_path(&fake_bin))
        .output()
        .expect("bootstrap should run");
    assert!(output.status.success());

    let elevate_logged =
        fs::read_to_string(&elevate_log).expect("fake elevate log should exist for run");
    assert!(elevate_logged.contains("build"));
    assert!(elevate_logged.contains("--exp-infer-local-bidi"));

    let cargo_logged = fs::read_to_string(&cargo_log).expect("fake cargo log should exist");
    assert!(cargo_logged.contains("run"));
    assert!(cargo_logged.contains("--manifest-path"));
    assert!(cargo_logged.contains("elevate-gen/Cargo.toml"));
    assert!(cargo_logged.contains("--seed"));
    assert!(cargo_logged.contains("7"));
}

fn temp_dir(prefix: &str) -> std::path::PathBuf {
    let nanos = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("system time should be valid")
        .as_nanos();
    let path = std::env::temp_dir().join(format!("{prefix}-{nanos}"));
    fs::create_dir_all(&path).expect("temp dir should be created");
    path
}

fn init_bin_project(root: &std::path::Path) {
    let output = Command::new(bin())
        .arg("init")
        .arg(root)
        .arg("--name")
        .arg("starter")
        .arg("--vcs")
        .arg("none")
        .arg("--bin")
        .output()
        .expect("run cli init should succeed");
    assert!(output.status.success());
}

fn build_bootstrap_binary(root: &std::path::Path, name: &str) -> std::path::PathBuf {
    let cargo = std::env::var("CARGO").unwrap_or_else(|_| "cargo".to_string());
    let output = Command::new(cargo)
        .arg("build")
        .arg("--manifest-path")
        .arg(root.join("Cargo.toml"))
        .output()
        .expect("bootstrap crate should build");
    assert!(output.status.success());
    root.join("target").join("debug").join(name)
}

fn install_fake_command(dir: &std::path::Path, name: &str, log_path: &std::path::Path, ok: bool) {
    let path = dir.join(name);
    let status = if ok { 0 } else { 1 };
    let script = format!(
        "#!/bin/sh\nprintf '%s\\n' \"$*\" >> \"{}\"\nexit {status}\n",
        log_path.display()
    );
    fs::write(&path, script).expect("fake command should be written");
    make_executable(&path);
}

#[cfg(unix)]
fn make_executable(path: &std::path::Path) {
    use std::os::unix::fs::PermissionsExt;
    let mut perms = fs::metadata(path).expect("metadata").permissions();
    perms.set_mode(0o755);
    fs::set_permissions(path, perms).expect("set permissions");
}

#[cfg(not(unix))]
fn make_executable(_path: &std::path::Path) {}

fn prepend_path(dir: &std::path::Path) -> String {
    let mut parts = vec![dir.to_path_buf()];
    if let Some(existing) = std::env::var_os("PATH") {
        parts.extend(std::env::split_paths(&existing));
    }
    std::env::join_paths(parts)
        .expect("join PATH entries")
        .to_string_lossy()
        .to_string()
}
