use crate::runtime;
use crate::runtime::Board;
use crate::runtime::RenderMode;
use crate::host::KeyEvent;

pub struct Game {
    runtime: i64;
    board: Board;
    puzzle_index: i64;
    cursor_row: i64;
    cursor_col: i64;
    render_mode: RenderMode;
    message: String;
    running: bool;
    needs_redraw: bool;
    debug_enabled: bool;
    fps_window_start_ms: i64;
    fps_frames: i64;
    fps_display: i64;
}

impl Game {
    pub fn new() -> Self {
        const runtime_handle = runtime::runtime_start();
        const board_state = Board::from_puzzle(0);
        const now_ms: i64 = runtime::runtime_now_millis();
        Game {
            runtime: runtime_handle;
            board: board_state;
            puzzle_index: 0;
            cursor_row: 0;
            cursor_col: 0;
            render_mode: runtime::default_render_mode();
            message: String::from("Use arrows/WASD, 1-9, 0 clear, c check, n next, r reset, v renderer, q quit");
            running: true;
            needs_redraw: true;
            debug_enabled: true;
            fps_window_start_ms: now_ms;
            fps_frames: 0;
            fps_display: 0;
        }
    }

    pub fn run(self) {
        while self.running {
            self = Game::tick_fps(self);

            if self.needs_redraw {
                self.board = runtime::runtime_render(
                    self.board,
                    self.cursor_row,
                    self.cursor_col,
                    format!("{}", self.message),
                    self.render_mode,
                    self.debug_enabled,
                    self.fps_display,
                );
                self.needs_redraw = false;
            }

            const key = runtime::runtime_poll_key(self.runtime);
            self = match key {
                Option::Some(value) => Game::on_key(self, value);
                Option::None => self;
            };
        }

        runtime::runtime_shutdown(self.runtime);
    }

    fn on_key(self, key: KeyEvent) -> Self {
        if key == KeyEvent::Quit {
            return Game::stop(self);
        }

        const next = match key {
            KeyEvent::Quit => Game::stop(self);
            KeyEvent::Up => Game::move_cursor(self, -1, 0);
            KeyEvent::Down => Game::move_cursor(self, 1, 0);
            KeyEvent::Left => Game::move_cursor(self, 0, -1);
            KeyEvent::Right => Game::move_cursor(self, 0, 1);
            KeyEvent::Digit(value) => Game::apply_digit(self, value);
            KeyEvent::Clear => Game::clear_cell(self);
            KeyEvent::Check => Game::check_status(self);
            KeyEvent::Next => Game::load_next_puzzle(self);
            KeyEvent::Reset => Game::reset_puzzle(self);
            KeyEvent::ToggleRenderer => Game::toggle_renderer(self);
            KeyEvent::ToggleDebug => Game::toggle_debug(self);
            KeyEvent::Hint => Game::set_message(self, String::from("Hint engine pending in Neon Boardwalk"));
            KeyEvent::Save => Game::set_message(self, String::from("Save pending in Neon Boardwalk"));
            KeyEvent::Load => Game::set_message(self, String::from("Load pending in Neon Boardwalk"));
        };
        Game::mark_dirty(next)
    }

    fn stop(self) -> Self {
        self.running = false;
        self
    }

    fn mark_dirty(self) -> Self {
        self.needs_redraw = true;
        self
    }

    fn set_message(self, message: String) -> Self {
        self.message = message;
        self
    }

    fn tick_fps(self) -> Self {
        const now: i64 = runtime::runtime_now_millis();
        self.fps_frames += 1;
        const elapsed: i64 = now - self.fps_window_start_ms;
        if elapsed >= 1000 {
            if elapsed > 0 {
                self.fps_display = (self.fps_frames * 1000) / elapsed;
            } else {
                self.fps_display = 0;
            }
            self.fps_frames = 0;
            self.fps_window_start_ms = now;
            if self.debug_enabled {
                self.needs_redraw = true;
            }
        }
        self
    }

    fn move_cursor(self, dr: i64, dc: i64) -> Self {
        self.cursor_row = wrap_0_to_8(self.cursor_row + dr);
        self.cursor_col = wrap_0_to_8(self.cursor_col + dc);
        self
    }

    fn apply_digit(self, value: i64) -> Self {
        const (next_board, ok) = Board::set(self.board, self.cursor_row, self.cursor_col, value);
        self.board = next_board;
        if ok {
            self.message = String::from("");
            return self;
        }
        self.message = String::from("Cannot edit fixed cell");
        self
    }

    fn clear_cell(self) -> Self {
        const (next_board, ok) = Board::clear(self.board, self.cursor_row, self.cursor_col);
        self.board = next_board;
        if ok {
            self.message = String::from("");
            return self;
        }
        self.message = String::from("Cannot clear fixed cell");
        self
    }

    fn check_status(self) -> Self {
        const (board_after_complete, complete) = Board::is_complete(self.board);
        self.board = board_after_complete;
        if complete {
            self.message = String::from("Solved! Press n for next puzzle or q to quit");
            return self;
        }
        const (board_after_conflict, conflict) = Board::has_conflict(self.board, self.cursor_row, self.cursor_col);
        self.board = board_after_conflict;
        if conflict {
            self.message = String::from("Current cell conflicts with row/column/box");
            return self;
        }
        self.message = String::from("No conflict in current cell. Keep going.");
        self
    }

    fn load_next_puzzle(self) -> Self {
        const total = runtime::puzzle_count();
        self.puzzle_index += 1;
        if self.puzzle_index >= total {
            self.puzzle_index = 0;
        }
        self.board = Board::from_puzzle(self.puzzle_index);
        self.cursor_row = 0;
        self.cursor_col = 0;
        self.message = format!("Loaded puzzle {}", self.puzzle_index + 1);
        self
    }

    fn reset_puzzle(self) -> Self {
        self.board = Board::from_puzzle(self.puzzle_index);
        self.cursor_row = 0;
        self.cursor_col = 0;
        self.message = String::from("Puzzle reset");
        self
    }

    fn toggle_renderer(self) -> Self {
        self.render_mode = runtime::toggle_render_mode(self.render_mode);
        self.message = format!(
            "Renderer switched to {} mode",
            runtime::render_mode_name(self.render_mode)
        );
        self
    }

    fn toggle_debug(self) -> Self {
        self.debug_enabled = not self.debug_enabled;
        self.message = match self.debug_enabled {
            true => String::from("Debug overlay enabled");
            false => String::from("Debug overlay disabled");
        };
        self
    }
}

fn wrap_0_to_8(value: i64) -> i64 {
    if value < 0 {
        return 8;
    }
    if value > 8 {
        return 0;
    }
    value
}
