rust use crate::runtime;
rust use crate::runtime::Board;
rust use crate::host::KeyEvent;

pub struct Game {
    runtime: i64;
    board: Board;
    puzzle_index: i64;
    cursor_row: i64;
    cursor_col: i64;
    message: String;
    running: bool;
}

impl Game {
    pub fn new() -> Self {
        const runtime_handle = runtime::runtime_start();
        const board_state = Board::from_puzzle(0);
        Game {
            runtime: runtime_handle;
            board: board_state;
            puzzle_index: 0;
            cursor_row: 0;
            cursor_col: 0;
            message: String::from("Use arrows/WASD, 1-9, 0 clear, c check, n next, r reset, q quit");
            running: true;
        }
    }

    pub fn run(self) {
        while self.running {
            self.board = runtime::runtime_render(
                self.board,
                self.cursor_row,
                self.cursor_col,
                format!("{}", self.message),
            );

            const key = runtime::runtime_poll_key(self.runtime);
            self = match key {
                Option::Some(value) => Game::on_key(self, value);
                Option::None => self;
            };
        }

        runtime::runtime_shutdown(self.runtime);
    }

    fn on_key(self, key: KeyEvent) -> Self {
        return match key {
            KeyEvent::Quit => Game::stop(self);
            KeyEvent::Up => Game::move_cursor(self, -1, 0);
            KeyEvent::Down => Game::move_cursor(self, 1, 0);
            KeyEvent::Left => Game::move_cursor(self, 0, -1);
            KeyEvent::Right => Game::move_cursor(self, 0, 1);
            KeyEvent::Digit(value) => Game::apply_digit(self, value);
            KeyEvent::Clear => Game::clear_cell(self);
            KeyEvent::Check => Game::check_status(self);
            KeyEvent::Next => Game::load_next_puzzle(self);
            KeyEvent::Reset => Game::reset_puzzle(self);
            KeyEvent::Hint => Game::set_message(self, String::from("Hint engine pending in Neon Boardwalk"));
            KeyEvent::Save => Game::set_message(self, String::from("Save pending in Neon Boardwalk"));
            KeyEvent::Load => Game::set_message(self, String::from("Load pending in Neon Boardwalk"));
        };
    }

    fn stop(self) -> Self {
        self.running = false;
        self
    }

    fn set_message(self, message: String) -> Self {
        self.message = message;
        self
    }

    fn move_cursor(self, dr: i64, dc: i64) -> Self {
        self.cursor_row = wrap_0_to_8(self.cursor_row + dr);
        self.cursor_col = wrap_0_to_8(self.cursor_col + dc);
        self
    }

    fn apply_digit(self, value: i64) -> Self {
        const (next_board, ok) = Board::set(self.board, self.cursor_row, self.cursor_col, value);
        self.board = next_board;
        if ok {
            self.message = String::from("");
            return self;
        }
        self.message = String::from("Cannot edit fixed cell");
        self
    }

    fn clear_cell(self) -> Self {
        const (next_board, ok) = Board::clear(self.board, self.cursor_row, self.cursor_col);
        self.board = next_board;
        if ok {
            self.message = String::from("");
            return self;
        }
        self.message = String::from("Cannot clear fixed cell");
        self
    }

    fn check_status(self) -> Self {
        const (board_after_complete, complete) = Board::is_complete(self.board);
        self.board = board_after_complete;
        if complete {
            self.message = String::from("Solved! Press n for next puzzle or q to quit");
            return self;
        }
        const (board_after_conflict, conflict) = Board::has_conflict(self.board, self.cursor_row, self.cursor_col);
        self.board = board_after_conflict;
        if conflict {
            self.message = String::from("Current cell conflicts with row/column/box");
            return self;
        }
        self.message = String::from("No conflict in current cell. Keep going.");
        self
    }

    fn load_next_puzzle(self) -> Self {
        const total = runtime::puzzle_count();
        self.puzzle_index += 1;
        if self.puzzle_index >= total {
            self.puzzle_index = 0;
        }
        self.board = Board::from_puzzle(self.puzzle_index);
        self.cursor_row = 0;
        self.cursor_col = 0;
        self.message = format!("Loaded puzzle {}", self.puzzle_index + 1);
        self
    }

    fn reset_puzzle(self) -> Self {
        self.board = Board::from_puzzle(self.puzzle_index);
        self.cursor_row = 0;
        self.cursor_col = 0;
        self.message = String::from("Puzzle reset");
        self
    }
}

fn wrap_0_to_8(value: i64) -> i64 {
    if value < 0 {
        return 8;
    }
    if value > 8 {
        return 0;
    }
    value
}
