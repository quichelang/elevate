use crate::host;
use crate::host::KeyEvent;
use crate::gfx::Canvas;
use crate::gamekit;

pub enum RenderMode {
    Neon;
    Vga;
}

pub fn default_render_mode() -> RenderMode {
    RenderMode::Vga
}

pub fn toggle_render_mode(mode: RenderMode) -> RenderMode {
    match mode {
        RenderMode::Neon => RenderMode::Vga;
        RenderMode::Vga => RenderMode::Neon;
    }
}

pub fn render_mode_name(mode: RenderMode) -> String {
    match mode {
        RenderMode::Neon => "Neon";
        RenderMode::Vga => "VGA";
    }
}

fn mode_is_vga(mode: RenderMode) -> bool {
    match mode {
        RenderMode::Vga => true;
        _ => false;
    }
}

pub struct Board {
    cells: Vec<i64>;
    fixed: Vec<bool>;
}

impl Board {
    pub fn from_puzzle(index: i64) -> Self {
        const text = puzzle_text(index);
        const cells = parse_cells(text);
        const fixed = build_fixed(cells);
        Board {
            cells: cells;
            fixed: fixed;
        }
    }

    pub fn get(self: Self, row: i64, col: i64) -> (Self, i64) {
        const index = board_index(row, col);
        if index < 0 {
            return (self, 0);
        }
        const value = self.cells[index];
        (self, value)
    }

    pub fn set(self: Self, row: i64, col: i64, value: i64) -> (Self, bool) {
        if value < 1 {
            return (self, false);
        }
        if value > 9 {
            return (self, false);
        }

        const index = board_index(row, col);
        if index < 0 {
            return (self, false);
        }
        Board::set_at_index(self, index, value)
    }

    pub fn clear(self: Self, row: i64, col: i64) -> (Self, bool) {
        const index = board_index(row, col);
        if index < 0 {
            return (self, false);
        }
        Board::set_at_index(self, index, 0)
    }

    pub fn row_values(self: Self, row: i64) -> (Self, Vec<i64>) {
        if row < 0 or row > 8 {
            return (self, []);
        }
        const start = row * 9;
        const end = start + 9;
        const values = self.cells[start..end];
        (self, values)
    }

    pub fn col_values(self: Self, col: i64) -> (Self, Vec<i64>) {
        if col < 0 or col > 8 {
            return (self, []);
        }
        let values: Vec<i64> = [];
        for row in 0..9 {
            values.push(self.cells[row * 9 + col]);
        }
        (self, values)
    }

    pub fn box_values(self: Self, row: i64, col: i64) -> (Self, Vec<i64>) {
        if row < 0 or row > 8 {
            return (self, []);
        }
        if col < 0 or col > 8 {
            return (self, []);
        }

        let values: Vec<i64> = [];
        const box_row = (row / 3) * 3;
        const box_col = (col / 3) * 3;
        for r in box_row..(box_row + 3) {
            for c in box_col..(box_col + 3) {
                values.push(self.cells[r * 9 + c]);
            }
        }
        (self, values)
    }

    pub fn has_conflict(self: Self, row: i64, col: i64) -> (Self, bool) {
        const (next_board, value) = Board::get(self, row, col);
        self = next_board;
        if value == 0 {
            return (self, false);
        }

        const (row_board, row_values) = Board::row_values(self, row);
        self = row_board;
        for c in 0..9 {
            if c != col {
                if row_values[c] == value {
                    return (self, true);
                }
            }
        }

        const (col_board, col_values) = Board::col_values(self, col);
        self = col_board;
        for r in 0..9 {
            if r != row {
                if col_values[r] == value {
                    return (self, true);
                }
            }
        }

        const box_row = (row / 3) * 3;
        const box_col = (col / 3) * 3;
        for r in box_row..(box_row + 3) {
            for c in box_col..(box_col + 3) {
                if r == row and c == col {
                    ()
                } else {
                    const (loop_board, candidate) = Board::get(self, r, c);
                    self = loop_board;
                    if candidate == value {
                        return (self, true);
                    }
                }
            }
        }

        (self, false)
    }

    pub fn is_complete(self: Self) -> (Self, bool) {
        for row in 0..9 {
            const (row_board, row_values) = Board::row_values(self, row);
            self = row_board;
            for value in row_values {
                if value == 0 {
                    return (self, false);
                }
            }

            for col in 0..9 {
                const (conflict_board, conflict) = Board::has_conflict(self, row, col);
                self = conflict_board;
                if conflict {
                    return (self, false);
                }
            }
        }

        (self, true)
    }

    fn set_at_index(self: Self, index: i64, value: i64) -> (Self, bool) {
        if self.fixed[index] {
            return (self, false);
        }
        self.cells[index] = value;
        (self, true)
    }
}

pub fn runtime_start() -> i64 {
    host::runtime_start()
}

pub fn runtime_poll_key(handle: i64) -> Option<KeyEvent> {
    host::runtime_poll_key(handle)
}

pub fn runtime_now_millis() -> i64 {
    host::runtime_now_millis()
}

pub fn runtime_shutdown(handle: i64) {
    host::runtime_shutdown(handle);
}

pub fn runtime_render(
    board: Board,
    cursor_row: i64,
    cursor_col: i64,
    message: String,
    mode: RenderMode,
    debug_enabled: bool,
    fps: i64,
) -> Board {
    const drawn = host::runtime_draw_scene(
        board.cells,
        board.fixed,
        cursor_row,
        cursor_col,
        format!("{}", message),
        mode_is_vga(mode),
        debug_enabled,
        fps,
    );
    if drawn {
        return board;
    }
    const (rendered_board, frame) = render_frame(
        board,
        cursor_row,
        cursor_col,
        message,
        mode,
        debug_enabled,
        fps,
    );
    host::runtime_draw(frame);
    rendered_board
}

pub fn puzzle_count() -> i64 {
    3
}

fn board_index(row: i64, col: i64) -> i64 {
    if row < 0 or row > 8 {
        return -1;
    }
    if col < 0 or col > 8 {
        return -1;
    }
    row * 9 + col
}

fn puzzle_text(index: i64) -> String {
    const normalized = normalize_puzzle_index(index);
    match normalized {
        0 => "530070000600195000098000060800060003400803001700020006060000280000419005000080079";
        1 => "009000000080605020501078000000000700706040102004000000000720903090301080000000600";
        _ => "000260701680070090190004500820100040004602900050003028009300074040050036703018000";
    }
}

fn normalize_puzzle_index(index: i64) -> i64 {
    const total = puzzle_count();
    if total == 0 {
        return 0;
    }
    const wrapped = index % total;
    if wrapped < 0 {
        return wrapped + total;
    }
    wrapped
}

fn parse_cells(text: String) -> Vec<i64> {
    let cells: Vec<i64> = [];
    for ch in text.chars() {
        cells.push(char_to_digit(ch));
    }
    cells
}

fn build_fixed(cells: Vec<i64>) -> Vec<bool> {
    let fixed: Vec<bool> = [];
    for value in cells {
        fixed.push(value != 0);
    }
    fixed
}

fn char_to_digit(ch: char) -> i64 {
    match ch {
        '0' => 0;
        '1' => 1;
        '2' => 2;
        '3' => 3;
        '4' => 4;
        '5' => 5;
        '6' => 6;
        '7' => 7;
        '8' => 8;
        '9' => 9;
        _ => 0;
    }
}

fn digit_to_char(value: i64) -> char {
    match value {
        0 => '.';
        1 => '1';
        2 => '2';
        3 => '3';
        4 => '4';
        5 => '5';
        6 => '6';
        7 => '7';
        8 => '8';
        9 => '9';
        _ => '?';
    }
}

fn render_frame(
    board: Board,
    cursor_row: i64,
    cursor_col: i64,
    message: String,
    mode: RenderMode,
    debug_enabled: bool,
    fps: i64,
) -> (Board, String) {
    const width = 120;
    const height = 42;
    const vga = mode_is_vga(mode);
    const canvas0 = Canvas::new(width, height, gamekit::palette_text(vga), gamekit::palette_bg(vga));
    const canvas1 = gamekit::draw_scene_shell(
        canvas0,
        render_mode_name(mode),
        format!("{}", message),
        debug_enabled,
        fps,
        vga,
    );
    const board_left = gamekit::board_left();
    const board_top = gamekit::board_top();
    const board_width = gamekit::board_width();
    const board_height = gamekit::board_height();
    const canvas2 = Canvas::fill_rect(
        canvas1,
        board_left,
        board_top,
        board_width,
        board_height,
        ' ',
        gamekit::palette_text(vga),
        gamekit::palette_board_bg(vga),
        false,
    );
    const (canvas3, next_board) = draw_board_rows(
        canvas2,
        board,
        cursor_row,
        cursor_col,
        board_left,
        board_top,
        mode,
        0,
    );
    const canvas4 = draw_debug_overlay(canvas3, mode, debug_enabled, fps);
    const canvas5 = gamekit::draw_gameplay_hints(canvas4, vga);
    const canvas6 = gamekit::draw_footer_status(canvas5, message, vga);
    const frame = Canvas::to_ansi(canvas6);
    (next_board, frame)
}

fn draw_debug_overlay(canvas: Canvas, mode: RenderMode, enabled: bool, fps: i64) -> Canvas {
    if not enabled {
        return canvas;
    }
    const text = format!("FPS {:>3}", fps);
    Canvas::text_top_right(
        canvas,
        0,
        text,
        theme_debug_fg(mode),
        theme_debug_bg(mode),
        true,
    )
}

fn draw_board_rows(
    canvas: Canvas,
    board: Board,
    cursor_row: i64,
    cursor_col: i64,
    left: i64,
    top: i64,
    mode: RenderMode,
    row: i64,
) -> (Canvas, Board) {
    if row >= 10 {
        return (canvas, board);
    }

    const sep_y = top + row * 2;
    const canvas_with_sep = draw_separator_line_offset(canvas, left, sep_y, row % 3 == 0, mode, 0);

    if row >= 9 {
        return (canvas_with_sep, board);
    }

    const value_y = sep_y + 1;
    const (row_board, row_values) = Board::row_values(board, row);
    const (canvas_after_values, board_after_values) = draw_value_line_cols(
        canvas_with_sep,
        row_board,
        row_values,
        row,
        value_y,
        left,
        cursor_row,
        cursor_col,
        mode,
        0,
    );

    draw_board_rows(
        canvas_after_values,
        board_after_values,
        cursor_row,
        cursor_col,
        left,
        top,
        mode,
        row + 1,
    )
}

fn draw_separator_line_offset(
    canvas: Canvas,
    left: i64,
    y: i64,
    major_row: bool,
    mode: RenderMode,
    offset: i64,
) -> Canvas {
    if offset >= 37 {
        return canvas;
    }

    const x = left + offset;
    const next_canvas = match offset % 4 == 0 {
        true => put_separator_vertical(canvas, x, y, mode, offset / 4);
        false => put_separator_horizontal(canvas, x, y, mode, major_row);
    };

    draw_separator_line_offset(next_canvas, left, y, major_row, mode, offset + 1)
}

fn put_separator_vertical(canvas: Canvas, x: i64, y: i64, mode: RenderMode, boundary_index: i64) -> Canvas {
    const major_col = is_major_boundary(boundary_index);
    const ch = separator_char(major_col);
    const fg = separator_fg(mode, major_col);
    Canvas::put(canvas, x, y, ch, fg, theme_panel_bg(mode), major_col)
}

fn put_separator_horizontal(canvas: Canvas, x: i64, y: i64, mode: RenderMode, major_row: bool) -> Canvas {
    const ch = match major_row {
        true => '=';
        false => '-';
    };
    const fg = match major_row {
        true => theme_grid_major_fg(mode);
        false => theme_grid_minor_fg(mode);
    };
    Canvas::put(canvas, x, y, ch, fg, theme_panel_bg(mode), major_row)
}

fn draw_value_line_cols(
    canvas: Canvas,
    board: Board,
    row_values: Vec<i64>,
    row: i64,
    y: i64,
    left: i64,
    cursor_row: i64,
    cursor_col: i64,
    mode: RenderMode,
    col: i64,
) -> (Canvas, Board) {
    if col >= 9 {
        const tail_major = is_major_boundary(9);
        const tail_ch = separator_char(tail_major);
        const tail_fg = separator_fg(mode, tail_major);
        const tail_x = left + 36;
        const tail_canvas = Canvas::put(canvas, tail_x, y, tail_ch, tail_fg, theme_panel_bg(mode), tail_major);
        return (tail_canvas, board);
    }

    const x = left + col * 4;
    const major_col = is_major_boundary(col);
    const sep_ch = separator_char(major_col);
    const sep_fg = separator_fg(mode, major_col);
    const canvas_with_sep = Canvas::put(canvas, x, y, sep_ch, sep_fg, theme_panel_bg(mode), major_col);
    const value = row_values[col];
    const is_cursor = row == cursor_row and col == cursor_col;
    const is_fixed = board.fixed[row * 9 + col];
    const (conflict_board, has_conflict) = Board::has_conflict(board, row, col);
    const canvas_with_cell = draw_cell_triplet(canvas_with_sep, x + 1, y, value, is_cursor, is_fixed, has_conflict, mode);

    draw_value_line_cols(
        canvas_with_cell,
        conflict_board,
        row_values,
        row,
        y,
        left,
        cursor_row,
        cursor_col,
        mode,
        col + 1,
    )
}

fn draw_cell_triplet(canvas: Canvas, x: i64, y: i64, value: i64, is_cursor: bool, is_fixed: bool, has_conflict: bool, mode: RenderMode) -> Canvas {
    const ch = digit_to_char(value);
    const cell_ch = match value == 0 {
        true => empty_cell_char(mode);
        false => ch;
    };
    const fg = cell_fg(mode, value, is_cursor, is_fixed, has_conflict);
    const bg = cell_bg(mode, value, is_cursor, is_fixed, has_conflict);
    const bold = is_cursor or is_fixed;
    const canvas0 = Canvas::put(canvas, x, y, ' ', fg, bg, bold);
    const canvas1 = Canvas::put(canvas0, x + 1, y, cell_ch, fg, bg, bold);
    Canvas::put(canvas1, x + 2, y, ' ', fg, bg, bold)
}

fn is_major_boundary(boundary_index: i64) -> bool {
    boundary_index == 0 or boundary_index == 3 or boundary_index == 6 or boundary_index == 9
}

fn separator_char(major: bool) -> char {
    if major {
        return '#';
    }
    '|'
}

fn separator_fg(mode: RenderMode, major: bool) -> i64 {
    if major {
        return theme_grid_major_fg(mode);
    }
    theme_grid_minor_fg(mode)
}

fn empty_cell_char(mode: RenderMode) -> char {
    match mode {
        RenderMode::Neon => '.';
        RenderMode::Vga => ':';
    }
}

fn cell_fg(mode: RenderMode, value: i64, is_cursor: bool, is_fixed: bool, has_conflict: bool) -> i64 {
    if is_cursor {
        return theme_cursor_fg(mode);
    }
    if has_conflict {
        return theme_conflict_fg(mode);
    }
    if value == 0 {
        return theme_dim_fg(mode);
    }
    if is_fixed {
        return theme_fixed_fg(mode);
    }
    theme_editable_fg(mode)
}

fn cell_bg(mode: RenderMode, value: i64, is_cursor: bool, is_fixed: bool, has_conflict: bool) -> i64 {
    if is_cursor {
        return theme_cursor_bg(mode);
    }
    if has_conflict {
        return theme_conflict_bg(mode);
    }
    if value == 0 {
        return theme_panel_bg(mode);
    }
    if is_fixed {
        return theme_fixed_bg(mode);
    }
    theme_editable_bg(mode)
}

fn theme_panel_bg(mode: RenderMode) -> i64 {
    gamekit::palette_board_bg(mode_is_vga(mode))
}

fn theme_grid_major_fg(mode: RenderMode) -> i64 {
    gamekit::palette_grid_major(mode_is_vga(mode))
}

fn theme_grid_minor_fg(mode: RenderMode) -> i64 {
    gamekit::palette_grid_minor(mode_is_vga(mode))
}

fn theme_dim_fg(mode: RenderMode) -> i64 {
    gamekit::palette_dim_fg(mode_is_vga(mode))
}

fn theme_fixed_fg(mode: RenderMode) -> i64 {
    gamekit::palette_fixed_fg(mode_is_vga(mode))
}

fn theme_fixed_bg(mode: RenderMode) -> i64 {
    gamekit::palette_fixed_bg(mode_is_vga(mode))
}

fn theme_editable_fg(mode: RenderMode) -> i64 {
    gamekit::palette_edit_fg(mode_is_vga(mode))
}

fn theme_editable_bg(mode: RenderMode) -> i64 {
    gamekit::palette_edit_bg(mode_is_vga(mode))
}

fn theme_cursor_fg(mode: RenderMode) -> i64 {
    gamekit::palette_cursor_fg(mode_is_vga(mode))
}

fn theme_cursor_bg(mode: RenderMode) -> i64 {
    gamekit::palette_cursor_bg(mode_is_vga(mode))
}

fn theme_conflict_fg(mode: RenderMode) -> i64 {
    gamekit::palette_conflict_fg(mode_is_vga(mode))
}

fn theme_conflict_bg(mode: RenderMode) -> i64 {
    gamekit::palette_conflict_bg(mode_is_vga(mode))
}

fn theme_debug_fg(mode: RenderMode) -> i64 {
    gamekit::palette_debug_fg(mode_is_vga(mode))
}

fn theme_debug_bg(mode: RenderMode) -> i64 {
    gamekit::palette_debug_bg(mode_is_vga(mode))
}
