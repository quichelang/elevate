rust use crate::host;
rust use crate::host::KeyEvent;

pub struct Board {
    cells: Vec<i64>;
    fixed: Vec<bool>;
}

impl Board {
    pub fn from_puzzle(index: i64) -> Self {
        const text = puzzle_text(index);
        const cells = parse_cells(text);
        const fixed = build_fixed(cells);
        Board {
            cells: cells;
            fixed: fixed;
        }
    }

    pub fn get(self: Self, row: i64, col: i64) -> (Self, i64) {
        const index = board_index(row, col);
        if index < 0 {
            return (self, 0);
        }
        const value = self.cells[index];
        (self, value)
    }

    pub fn set(self: Self, row: i64, col: i64, value: i64) -> (Self, bool) {
        if value < 1 {
            return (self, false);
        }
        if value > 9 {
            return (self, false);
        }

        const index = board_index(row, col);
        if index < 0 {
            return (self, false);
        }
        Board::set_at_index(self, index, value)
    }

    pub fn clear(self: Self, row: i64, col: i64) -> (Self, bool) {
        const index = board_index(row, col);
        if index < 0 {
            return (self, false);
        }
        Board::set_at_index(self, index, 0)
    }

    pub fn row_values(self: Self, row: i64) -> (Self, Vec<i64>) {
        if row < 0 or row > 8 {
            return (self, []);
        }
        const start = row * 9;
        const end = start + 9;
        const values = self.cells[start..end];
        (self, values)
    }

    pub fn col_values(self: Self, col: i64) -> (Self, Vec<i64>) {
        if col < 0 or col > 8 {
            return (self, []);
        }
        const values: Vec<i64> = [];
        for row in 0..9 {
            values.push(self.cells[row * 9 + col]);
        }
        (self, values)
    }

    pub fn box_values(self: Self, row: i64, col: i64) -> (Self, Vec<i64>) {
        if row < 0 or row > 8 {
            return (self, []);
        }
        if col < 0 or col > 8 {
            return (self, []);
        }

        const values: Vec<i64> = [];
        const box_row = (row / 3) * 3;
        const box_col = (col / 3) * 3;
        for r in box_row..(box_row + 3) {
            for c in box_col..(box_col + 3) {
                values.push(self.cells[r * 9 + c]);
            }
        }
        (self, values)
    }

    pub fn has_conflict(self: Self, row: i64, col: i64) -> (Self, bool) {
        const (next_board, value) = Board::get(self, row, col);
        self = next_board;
        if value == 0 {
            return (self, false);
        }

        const (row_board, row_values) = Board::row_values(self, row);
        self = row_board;
        for c in 0..9 {
            if c != col {
                if row_values[c] == value {
                    return (self, true);
                }
            }
        }

        const (col_board, col_values) = Board::col_values(self, col);
        self = col_board;
        for r in 0..9 {
            if r != row {
                if col_values[r] == value {
                    return (self, true);
                }
            }
        }

        const box_row = (row / 3) * 3;
        const box_col = (col / 3) * 3;
        for r in box_row..(box_row + 3) {
            for c in box_col..(box_col + 3) {
                if r == row and c == col {
                    ()
                } else {
                    const (next_board, candidate) = Board::get(self, r, c);
                    self = next_board;
                    if candidate == value {
                        return (self, true);
                    }
                }
            }
        }

        (self, false)
    }

    pub fn is_complete(self: Self) -> (Self, bool) {
        for row in 0..9 {
            const (row_board, row_values) = Board::row_values(self, row);
            self = row_board;
            for value in row_values {
                if value == 0 {
                    return (self, false);
                }
            }

            for col in 0..9 {
                const (conflict_board, conflict) = Board::has_conflict(self, row, col);
                self = conflict_board;
                if conflict {
                    return (self, false);
                }
            }
        }

        (self, true)
    }

    fn set_at_index(self: Self, index: i64, value: i64) -> (Self, bool) {
        if self.fixed[index] {
            return (self, false);
        }
        self.cells[index] = value;
        (self, true)
    }
}

pub fn runtime_start() -> i64 {
    host::runtime_start()
}

pub fn runtime_poll_key(handle: i64) -> Option<KeyEvent> {
    host::runtime_poll_key(handle)
}

pub fn runtime_shutdown(handle: i64) {
    host::runtime_shutdown(handle);
}

pub fn runtime_render(board: Board, cursor_row: i64, cursor_col: i64, message: String) -> Board {
    const (next_board, frame) = render_frame(board, cursor_row, cursor_col, message);
    host::runtime_draw(frame);
    next_board
}

pub fn puzzle_count() -> i64 {
    3
}

fn board_index(row: i64, col: i64) -> i64 {
    if row < 0 or row > 8 {
        return -1;
    }
    if col < 0 or col > 8 {
        return -1;
    }
    row * 9 + col
}

fn puzzle_text(index: i64) -> String {
    const normalized = normalize_puzzle_index(index);
    match normalized {
        0 => "530070000600195000098000060800060003400803001700020006060000280000419005000080079";
        1 => "009000000080605020501078000000000700706040102004000000000720903090301080000000600";
        _ => "000260701680070090190004500820100040004602900050003028009300074040050036703018000";
    }
}

fn normalize_puzzle_index(index: i64) -> i64 {
    const total = puzzle_count();
    if total == 0 {
        return 0;
    }
    const wrapped = index % total;
    if wrapped < 0 {
        return wrapped + total;
    }
    wrapped
}

fn parse_cells(text: String) -> Vec<i64> {
    const cells: Vec<i64> = [];
    for ch in text.chars() {
        cells.push(char_to_digit(ch));
    }
    cells
}

fn build_fixed(cells: Vec<i64>) -> Vec<bool> {
    const fixed: Vec<bool> = [];
    for value in cells {
        fixed.push(value != 0);
    }
    fixed
}

fn char_to_digit(ch: char) -> i64 {
    match ch {
        '0' => 0;
        '1' => 1;
        '2' => 2;
        '3' => 3;
        '4' => 4;
        '5' => 5;
        '6' => 6;
        '7' => 7;
        '8' => 8;
        '9' => 9;
        _ => 0;
    }
}

fn render_frame(board: Board, cursor_row: i64, cursor_col: i64, message: String) -> (Board, String) {
    const frame: String = String::from("\x1b[H");
    frame.push_str(render_background_strip(0));
    frame.push_str(render_background_strip(1));
    frame.push_str(render_background_strip(2));
    frame.push_str(render_background_strip(3));
    frame.push_str(render_background_strip(4));
    frame.push_str("\n");
    frame.push_str("\x1b[1;38;5;123m  NEON BOARDWALK :: SUDOKU GRID\x1b[0m\n");
    frame.push_str("\x1b[38;5;81m  ##=================##=================##=================##\x1b[0m\n");

    for row in 0..9 {
        if row > 0 {
            if row % 3 == 0 {
                frame.push_str("\x1b[38;5;81m  ##=================##=================##=================##\x1b[0m");
            } else {
                frame.push_str("\x1b[38;5;33m  ||-----------------||-----------------||-----------------||\x1b[0m");
            }
            frame.push_str("\x1b[48;5;236m  \x1b[0m\n");
        }

        frame.push_str("\x1b[38;5;81m  ||\x1b[0m");
        const (next_board, row_values) = Board::row_values(board, row);
        board = next_board;

        for col in 0..9 {
            const value = row_values[col];
            const is_cursor = row == cursor_row and col == cursor_col;
            const is_fixed = board.fixed[row * 9 + col];
            const (conflict_board, has_conflict) = Board::has_conflict(board, row, col);
            board = conflict_board;
            const cell = render_cell(value, is_cursor, is_fixed, has_conflict);
            frame.push_str(cell);

            if col % 3 == 2 {
                frame.push_str("\x1b[38;5;81m||\x1b[0m");
            } else {
                frame.push_str("\x1b[38;5;33m|\x1b[0m");
            }
        }
        frame.push_str("\x1b[48;5;236m  \x1b[0m\n");
    }

    frame.push_str("\x1b[38;5;81m  ##=================##=================##=================##\x1b[0m\x1b[48;5;236m  \x1b[0m\n");
    frame.push_str("\x1b[48;5;236m   \x1b[48;5;235m                                                       \x1b[0m\n");
    frame.push_str("\x1b[48;5;236m    \x1b[48;5;234m                                                      \x1b[0m\n\n");
    frame.push_str("\x1b[38;5;153m  Controls:\x1b[0m arrows/WASD move | 1-9 set | 0/space/backspace clear\n");
    frame.push_str("\x1b[38;5;153m            \x1b[0m c check | n next | r reset | q quit\n");
    frame.push_str("\x1b[1;38;5;220m  Status:\x1b[0m ");
    frame.push_str(message);
    frame.push_str("\n\n");
    (board, frame)
}

fn render_cell(value: i64, is_cursor: bool, is_fixed: bool, has_conflict: bool) -> String {
    const ch = digit_to_char(value);
    if is_cursor {
        return format!("\x1b[48;5;226m\x1b[1;38;5;16m {} \x1b[0m", ch);
    }
    if has_conflict {
        return format!("\x1b[48;5;52m\x1b[1;38;5;210m {} \x1b[0m", ch);
    }
    if value == 0 {
        return String::from("\x1b[48;5;236m\x1b[38;5;244m . \x1b[0m");
    }
    if is_fixed {
        return format!("\x1b[48;5;24m\x1b[1;38;5;231m {} \x1b[0m", ch);
    }
    format!("\x1b[48;5;238m\x1b[38;5;195m {} \x1b[0m", ch)
}

fn digit_to_char(value: i64) -> char {
    match value {
        0 => '.';
        1 => '1';
        2 => '2';
        3 => '3';
        4 => '4';
        5 => '5';
        6 => '6';
        7 => '7';
        8 => '8';
        9 => '9';
        _ => '?';
    }
}

fn render_background_strip(index: i64) -> String {
    match index {
        0 => "\x1b[48;5;17m                                                                                \x1b[0m\n";
        1 => "\x1b[48;5;18m    .---.      .---.      .---.      .---.      .---.      .---.             \x1b[0m\n";
        2 => "\x1b[48;5;19m   /_#_#_\\    /_#_#_\\    /_#_#_\\    /_#_#_\\    /_#_#_\\    /_#_#_\\            \x1b[0m\n";
        3 => "\x1b[48;5;20m   |#|#|#|    |#|#|#|    |#|#|#|    |#|#|#|    |#|#|#|    |#|#|#|            \x1b[0m\n";
        _ => "\x1b[48;5;21m================================================================================\x1b[0m\n";
    }
}
