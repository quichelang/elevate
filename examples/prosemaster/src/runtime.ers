use crate::host;
use crate::host::KeyEvent;
use crate::gfx::Canvas;
use crate::gamekit;
use crate::numeric;

pub enum DisplayMode {
    Terminal;
    Window;
}

pub enum PlaceFromRackError {
    InvalidRackSlot;
    EmptyRackSlot;
    CellUnavailable;
}

pub enum PlaceFromRackResult {
    Placed;
    Rejected(PlaceFromRackError);
}

pub enum SubmitTurnError {
    NoPendingTiles;
    NotSingleAxis;
    NonContiguousSpan;
    MissingCenterOnFirstMove;
    NotConnectedToCommitted;
    NoValidWordCreated;
}

pub enum SubmitTurnResult {
    Accepted;
    Rejected(SubmitTurnError);
}

pub fn default_display_mode() -> DisplayMode {
    DisplayMode::Window
}

pub fn toggle_display_mode(mode: DisplayMode) -> DisplayMode {
    match mode {
        DisplayMode::Terminal => DisplayMode::Window;
        DisplayMode::Window => DisplayMode::Terminal;
    }
}

pub fn display_mode_name(mode: DisplayMode) -> String {
    match mode {
        DisplayMode::Terminal => "Terminal";
        DisplayMode::Window => "SDL/OpenGL";
    }
}

fn display_mode_prefers_window(mode: DisplayMode) -> bool {
    match mode {
        DisplayMode::Window => true;
        _ => false;
    }
}

pub struct Board {
    cells: Vec<i64>;
    committed: Vec<bool>;
    pending: Vec<bool>;
    rack: Vec<i64>;
    bag_count: u64;
    score_total: u64;
    last_turn_score: u64;
    turn_number: u64;
    first_move_done: bool;
    rng_seed: u64;
}

impl Board {
    pub fn new(seed: i64) -> Self {
        const size = board_area();
        let cells: Vec<i64> = [];
        let committed: Vec<bool> = [];
        let pending: Vec<bool> = [];
        for _ in 0..size {
            cells.push(0);
            committed.push(false);
            pending.push(false);
        }

        const rack0 = empty_rack();
        const seed_u64 = numeric::to_nonneg_u64(seed);
        let board = Board {
            cells: cells;
            committed: committed;
            pending: pending;
            rack: rack0;
            bag_count: numeric::to_nonneg_u64(98);
            score_total: u64::MIN;
            last_turn_score: u64::MIN;
            turn_number: numeric::count_inc(u64::MIN);
            first_move_done: false;
            rng_seed: seed_u64;
        };
        Board::refill_rack(board)
    }

    pub fn turn_number(self: Self) -> u64 {
        self.turn_number
    }

    pub fn score_total(self: Self) -> u64 {
        self.score_total
    }

    pub fn last_turn_score(self: Self) -> u64 {
        self.last_turn_score
    }

    pub fn tiles_left(self: Self) -> u64 {
        self.bag_count
    }

    pub fn rack_letter(self: Self, slot: i64) -> i64 {
        if slot < 0 or slot > 6 {
            return 0;
        }
        self.rack[slot]
    }

    pub fn next_filled_slot(self: Self, from_slot: i64) -> i64 {
        let step = 1;
        while step < 8 {
            const slot = (from_slot + step) % 7;
            if self.rack[slot] > 0 {
                return slot;
            }
            step = step + 1;
        }
        0
    }

    pub fn place_from_rack(self: Self, row: i64, col: i64, slot: i64) -> (Self, PlaceFromRackResult) {
        if slot < 0 or slot > 6 {
            return (self, PlaceFromRackResult::Rejected(PlaceFromRackError::InvalidRackSlot));
        }
        const tile = self.rack[slot];
        if tile <= 0 {
            return (self, PlaceFromRackResult::Rejected(PlaceFromRackError::EmptyRackSlot));
        }
        const idx = board_index(row, col);
        if idx < 0 {
            return (self, PlaceFromRackResult::Rejected(PlaceFromRackError::CellUnavailable));
        }
        if self.cells[idx] != 0 {
            return (self, PlaceFromRackResult::Rejected(PlaceFromRackError::CellUnavailable));
        }

        self.cells[idx] = tile;
        self.pending[idx] = true;
        self.rack[slot] = 0;
        (self, PlaceFromRackResult::Placed)
    }

    pub fn remove_pending(self: Self, row: i64, col: i64) -> (Self, bool) {
        const idx = board_index(row, col);
        if idx < 0 {
            return (self, false);
        }
        if not self.pending[idx] {
            return (self, false);
        }

        const tile = self.cells[idx];
        self.cells[idx] = 0;
        self.pending[idx] = false;
        self = Board::insert_into_rack(self, tile);
        (self, true)
    }

    pub fn recall_turn_tiles(self: Self) -> (Self, u64) {
        let count = u64::MIN;
        let idx = 0;
        while idx < board_area() {
            if self.pending[idx] {
                const tile = self.cells[idx];
                self.cells[idx] = 0;
                self.pending[idx] = false;
                self = Board::insert_into_rack(self, tile);
                count = numeric::count_inc(count);
            }
            idx = idx + 1;
        }
        (self, count)
    }

    pub fn shuffle_rack(self: Self) -> Self {
        let i = 0;
        while i < 7 {
            const (seed, pick) = next_random_index(self.rng_seed, 7);
            self.rng_seed = seed;
            const j = (i + pick) % 7;
            const tmp = self.rack[i];
            self.rack[i] = self.rack[j];
            self.rack[j] = tmp;
            i = i + 1;
        }
        self
    }

    pub fn sort_rack(self: Self) -> Self {
        let pass = 0;
        while pass < 7 {
            let i = 0;
            while i < 6 {
                const left = self.rack[i];
                const right = self.rack[i + 1];
                if rank_tile_for_sort(right) > rank_tile_for_sort(left) {
                    const tmp = self.rack[i];
                    self.rack[i] = self.rack[i + 1];
                    self.rack[i + 1] = tmp;
                }
                i = i + 1;
            }
            pass = pass + 1;
        }
        self
    }

    pub fn submit_turn(self: Self) -> (Self, SubmitTurnResult) {
        const pending_positions = collect_pending_positions(self.pending);
        let pending_count = 0;
        for _ in pending_positions {
            pending_count = pending_count + 1;
        }
        if pending_count == 0 {
            return (self, SubmitTurnResult::Rejected(SubmitTurnError::NoPendingTiles));
        }

        const (axis_code, anchor, span_start, span_end) = placement_axis(pending_positions);
        if axis_code < 0 {
            return (self, SubmitTurnResult::Rejected(SubmitTurnError::NotSingleAxis));
        }
        if not placement_span_is_contiguous(self.cells, axis_code, anchor, span_start, span_end) {
            return (self, SubmitTurnResult::Rejected(SubmitTurnError::NonContiguousSpan));
        }

        if not self.first_move_done {
            if not pending_touches_center(self.pending) {
                return (self, SubmitTurnResult::Rejected(SubmitTurnError::MissingCenterOnFirstMove));
            }
        } else {
            if not pending_connects_to_committed(self.pending, self.committed) {
                return (self, SubmitTurnResult::Rejected(SubmitTurnError::NotConnectedToCommitted));
            }
        }

        const (main_score, main_word_len) = score_main_word(self.cells, self.pending, axis_code, anchor, span_start, span_end);
        let turn_score = main_score;
        let word_count = 0;
        if main_word_len > 1 {
            word_count = 1;
        }

        for pos in pending_positions {
            const row = pos / board_size();
            const col = pos % board_size();
            const (cross_score, cross_len) = score_cross_word(self.cells, self.pending, axis_code, row, col);
            if cross_len > 1 {
                turn_score = i64::saturating_add(turn_score, cross_score);
                word_count = i64::saturating_add(word_count, 1);
            }
        }

        if word_count == 0 {
            return (self, SubmitTurnResult::Rejected(SubmitTurnError::NoValidWordCreated));
        }

        if pending_count == 7 {
            turn_score = i64::saturating_add(turn_score, 50);
        }

        let idx = 0;
        while idx < board_area() {
            if self.pending[idx] {
                self.pending[idx] = false;
                self.committed[idx] = true;
            }
            idx = idx + 1;
        }

        const turn_score_u64 = numeric::to_nonneg_u64(turn_score);
        self.score_total = numeric::score_add(self.score_total, turn_score_u64);
        self.last_turn_score = turn_score_u64;
        self.turn_number = numeric::count_inc(self.turn_number);
        self.first_move_done = true;
        self = Board::refill_rack(self);
        (self, SubmitTurnResult::Accepted)
    }

    fn insert_into_rack(self: Self, tile: i64) -> Self {
        if tile <= 0 {
            return self;
        }
        let i = 0;
        while i < 7 {
            if self.rack[i] == 0 {
                self.rack[i] = tile;
                return self;
            }
            i = i + 1;
        }
        self.bag_count = numeric::count_inc(self.bag_count);
        self
    }

    fn refill_rack(self: Self) -> Self {
        let slot = 0;
        while slot < 7 {
            if self.rack[slot] == 0 {
                const (next_board, tile) = Board::draw_tile(self);
                self = next_board;
                self.rack[slot] = tile;
            }
            slot = slot + 1;
        }
        self
    }

    fn draw_tile(self: Self) -> (Self, i64) {
        if self.bag_count == u64::MIN {
            return (self, 0);
        }
        const (seed, index) = next_random_index(self.rng_seed, 98);
        self.rng_seed = seed;
        self.bag_count = numeric::count_dec(self.bag_count);
        const tile = weighted_tile(index);
        (self, tile)
    }
}

pub fn runtime_start() -> i64 {
    install_portrait_sprites();
    const mode = resolve_runtime_backend_mode();
    host::runtime_start_mode(mode)
}

pub fn runtime_poll_key(handle: i64) -> Option<KeyEvent> {
    host::runtime_poll_key(handle)
}

pub fn runtime_now_millis() -> i64 {
    host::runtime_now_millis()
}

pub fn runtime_shutdown(handle: i64) {
    host::runtime_shutdown(handle);
}

fn resolve_runtime_backend_mode() -> String {
    const window_flag = host::runtime_window_opt_in();
    const backend_hint = host::runtime_backend_hint();

    if window_flag == 0 {
        return String::from("terminal");
    }
    if window_flag == 1 {
        if backend_hint == "minifb" {
            return String::from("minifb");
        }
        return String::from("sdl");
    }
    if backend_hint == "minifb" {
        return String::from("minifb");
    }
    if backend_hint == "sdl" {
        return String::from("sdl");
    }
    String::from("terminal")
}

fn install_portrait_sprites() {
    const (player_width, player_height, player_pixels) = build_portrait_sprite(true);
    const (cpu_width, cpu_height, cpu_pixels) = build_portrait_sprite(false);
    host::runtime_set_portrait_sprites(
        player_width,
        player_height,
        player_pixels,
        cpu_width,
        cpu_height,
        cpu_pixels,
    );
}

fn build_portrait_sprite(is_player: bool) -> (i64, i64, Vec<i64>) {
    const rows = portrait_rows(is_player);
    parse_portrait_rows(rows, is_player)
}

fn parse_portrait_rows(rows: Vec<String>, is_player: bool) -> (i64, i64, Vec<i64>) {
    let pixels: Vec<i64> = [];
    let row = 0;
    while row < 32 {
        const row_text = format!("{}", rows[row]);
        let col = 0;
        for token in row_text.chars() {
            if col < 32 {
                pixels.push(sprite_color(token, is_player));
                col = col + 1;
            }
        }
        while col < 32 {
            pixels.push(-1);
            col = col + 1;
        }
        row = row + 1;
    }
    (32, 32, pixels)
}

fn portrait_rows(is_player: bool) -> Vec<String> {
    let rows: Vec<String> = [];
    if is_player {
        rows.push(String::from("................................"));
        rows.push(String::from("................................"));
        rows.push(String::from(".............rrrrrrrrrr........."));
        rows.push(String::from("..........rrrrrrrrrrrrrrrr......"));
        rows.push(String::from("........rrrrrrrrrrrrrrrrrrrr...."));
        rows.push(String::from(".......rrrkkkkrrrrrrrrkkkkrr...."));
        rows.push(String::from("......rrrkkkkkkrrrrrrkkkkkkrr..."));
        rows.push(String::from("......rrrrrrrrrrrrrrrrrrrrrrr..."));
        rows.push(String::from(".....rrrwwwwwwwwwwwwwwwwwwrrr..."));
        rows.push(String::from(".....rrwwwwwwwwwwwwwwwwwwwwrr..."));
        rows.push(String::from(".....rrwwwwssssssssssssswwwwrr.."));
        rows.push(String::from(".....rrwwsssssssssssssssswwrr..."));
        rows.push(String::from(".....rrwssssshhhhsshhhsssswrr..."));
        rows.push(String::from(".....rrwsssshhhhhhshhhhhssswrr.."));
        rows.push(String::from(".....rrwsssshhhhhhshhhhhssswrr.."));
        rows.push(String::from(".....rrwssssskssssssssksssswrr.."));
        rows.push(String::from(".....rrwssssskssssssssksssswrr.."));
        rows.push(String::from(".....rrwssssssssssssssssssswrr.."));
        rows.push(String::from(".....rrwssssssshhhhhssssssswrr.."));
        rows.push(String::from(".....rrwwsssssssssssssssswwrr..."));
        rows.push(String::from(".....rrrwwsssssssssssssswwrrr..."));
        rows.push(String::from("......rrrwwwwsssssssswwwwrrr...."));
        rows.push(String::from(".......rrrwwwwwwwwwwwwrrr......."));
        rows.push(String::from(".......rrrbbbebbbbbbebbbrrr....."));
        rows.push(String::from(".......rrbbbeebbbbbeebbbrrr....."));
        rows.push(String::from(".......rbbbeeeebbbeeeebbbrr....."));
        rows.push(String::from(".......rbbbbbeeeeeeeebbbbrr....."));
        rows.push(String::from(".......rrbbbbbbbbbbbbbbbrr......"));
        rows.push(String::from("........rrrbbbbbbbbbbbrrr......."));
        rows.push(String::from(".........rrrrbbbbbbbrrrr........"));
        rows.push(String::from("...........rrrrrrrrrr..........."));
        rows.push(String::from("................................"));
        return rows;
    }

    rows.push(String::from("................................"));
    rows.push(String::from("............hhhhhhhh............"));
    rows.push(String::from(".........hhhhhhhhhhhhhh........."));
    rows.push(String::from(".......hhhhhhhhhhhhhhhhhh......."));
    rows.push(String::from("......hhhkkkkhhhhhhhhkkkkhh....."));
    rows.push(String::from(".....hhhkkkkkkhhhhhhkkkkkkhh...."));
    rows.push(String::from(".....hhhkkkkkkkkkkkkkkkkkkhh...."));
    rows.push(String::from(".....hhwwwwwwwwwwwwwwwwwwwhh...."));
    rows.push(String::from(".....hwwwwwwwwwwwwwwwwwwwwwrh..."));
    rows.push(String::from("....hhwwwwsssssssssssssswwwhh..."));
    rows.push(String::from("....hwwwsssssssssssssssssswwh..."));
    rows.push(String::from("....hwwsssshhhhhssshhhhhssswh..."));
    rows.push(String::from("....hwwssshhhhhhssshhhhhhsswh..."));
    rows.push(String::from("....hwwssshhhhhsssshhhhhhsswh..."));
    rows.push(String::from("....hwwsssskkkksssskkkksssswh..."));
    rows.push(String::from("....hwwsssskkkksssskkkksssswh..."));
    rows.push(String::from("....hwwsssssssssssssssssssswh..."));
    rows.push(String::from("....hwwssssswwssssssssssssswh..."));
    rows.push(String::from("....hwwsssswwwwsssssssssssswh..."));
    rows.push(String::from("....hhwwsssssssssssssssssswwh..."));
    rows.push(String::from(".....hwwwwsssssssssssssswwwh...."));
    rows.push(String::from(".....hhwwwwwwwwwwwwwwwwwwhh....."));
    rows.push(String::from(".....hhbbbbbbbbbebbbbbbbrhh....."));
    rows.push(String::from("......hbbbbbbbbeeebbbbbbrh......"));
    rows.push(String::from("......hbbbbbbbeeeeebbbbbrh......"));
    rows.push(String::from("......hhbbbbbeeeeeebbbbhh......."));
    rows.push(String::from(".......hhbbbbbbbbbbbbbhh........"));
    rows.push(String::from("........hhhbbbbbbbbbhhh........."));
    rows.push(String::from(".........hhhhbbbbhhhh..........."));
    rows.push(String::from("...........hhhhhhhh............."));
    rows.push(String::from("................................"));
    rows.push(String::from("................................"));
    rows
}

fn sprite_color(token: char, is_player: bool) -> i64 {
    if token == ' ' or token == '.' {
        return -1;
    }
    if token == '#' {
        return rgb_i64(22, 18, 24);
    }
    if token == 'w' {
        return rgb_i64(255, 255, 255);
    }
    if token == 's' {
        if is_player {
            return rgb_i64(242, 184, 140);
        }
        return rgb_i64(235, 188, 159);
    }
    if token == 'h' {
        return rgb_i64(99, 54, 29);
    }
    if token == 'r' {
        return rgb_i64(198, 53, 47);
    }
    if token == 'b' {
        if is_player {
            return rgb_i64(24, 86, 195);
        }
        return rgb_i64(127, 63, 162);
    }
    if token == 'e' {
        return rgb_i64(37, 97, 170);
    }
    if token == 'g' {
        return rgb_i64(54, 150, 82);
    }
    if token == 'y' {
        return rgb_i64(248, 224, 109);
    }
    if token == 'k' {
        return rgb_i64(13, 11, 16);
    }
    rgb_i64(255, 0, 255)
}

fn rgb_i64(r: i64, g: i64, b: i64) -> i64 {
    r * 65536 + g * 256 + b
}

pub fn runtime_render(
    board: Board,
    cursor_row: i64,
    cursor_col: i64,
    message: String,
    display_mode: DisplayMode,
    debug_enabled: bool,
    fps: i64,
    player_name: String,
    level_label: String,
    elapsed_secs: i64,
    quit_armed: bool,
    selected_slot: i64,
) -> Board {
    const vga = true;
    const time_label = format_elapsed_clock(elapsed_secs);
    if display_mode_prefers_window(display_mode) {
        const drawn = host::runtime_draw_scene(
            board.cells,
            board.committed,
            cursor_row,
            cursor_col,
            format!("{}", message),
            vga,
            debug_enabled,
            fps,
            player_name,
            level_label,
            time_label,
            quit_armed,
            false,
        );

        if drawn {
            return board;
        }
    }

    const (next_board, frame) = render_frame(
        board,
        cursor_row,
        cursor_col,
        message,
        vga,
        debug_enabled,
        fps,
        elapsed_secs,
        selected_slot,
        quit_armed,
    );
    host::runtime_draw(frame);
    next_board
}

pub fn letter_to_string(letter: i64) -> String {
    format!("{}", letter_to_char(letter))
}

pub fn place_result_message(result: PlaceFromRackResult, slot: i64) -> String {
    match result {
        PlaceFromRackResult::Placed => format!("Placed tile from rack {}", slot_label(slot));
        PlaceFromRackResult::Rejected(error) => match error {
            PlaceFromRackError::InvalidRackSlot => String::from("Pick a rack slot from 1-7");
            PlaceFromRackError::EmptyRackSlot => String::from("That rack slot is empty");
            PlaceFromRackError::CellUnavailable => String::from("Cell already occupied");
        };
    }
}

pub fn submit_result_message(result: SubmitTurnResult, points: u64) -> String {
    match result {
        SubmitTurnResult::Accepted => format!("Turn accepted: +{} points", points);
        SubmitTurnResult::Rejected(error) => match error {
            SubmitTurnError::NoPendingTiles => String::from("Place at least one tile before submitting");
            SubmitTurnError::NotSingleAxis => String::from("Turn tiles must be in one row or one column");
            SubmitTurnError::NonContiguousSpan => String::from("Turn tiles must form one contiguous line");
            SubmitTurnError::MissingCenterOnFirstMove => String::from("First turn must cover the center star");
            SubmitTurnError::NotConnectedToCommitted => String::from("Turn must connect to existing words");
            SubmitTurnError::NoValidWordCreated => String::from("Turn must create at least one 2+ letter word");
        };
    }
}

fn render_frame(
    board: Board,
    cursor_row: i64,
    cursor_col: i64,
    message: String,
    vga: bool,
    debug_enabled: bool,
    fps: i64,
    elapsed_secs: i64,
    selected_slot: i64,
    quit_armed: bool,
) -> (Board, String) {
    const width = 120;
    const height = 42;
    const canvas0 = Canvas::new(width, height, gamekit::palette_text(vga), gamekit::palette_bg(vga));
    const canvas1 = gamekit::draw_scene_shell(
        canvas0,
        String::from("PROSEMASTER"),
        format!("TURN {}", board.turn_number),
        debug_enabled,
        fps,
        vga,
    );

    const canvas2 = draw_board(canvas1, board, cursor_row, cursor_col, vga, selected_slot);
    const canvas3 = draw_hud(canvas2, board, elapsed_secs, vga);
    const canvas4 = gamekit::draw_gameplay_hints(canvas3, vga);
    const canvas5 = gamekit::draw_footer_status(canvas4, message, vga);
    const canvas6 = draw_control_hint(canvas5, vga);
    const canvas7 = draw_quit_prompt(canvas6, vga, quit_armed);
    (board, Canvas::to_ansi(canvas7))
}

fn draw_board(canvas: Canvas, board: Board, cursor_row: i64, cursor_col: i64, vga: bool, selected_slot: i64) -> Canvas {
    const left: i64 = gamekit::board_left();
    const top: i64 = gamekit::board_top();
    const header = Canvas::text(canvas, left + 2, top - 2, "  A B C D E F G H I J K L M N O", gamekit::palette_hud_text(vga), gamekit::palette_bg(vga), false);
    let out = header;

    let row: i64 = 0;
    while row < 15 {
        out = draw_row_label(out, row, left, top, vga);
        let col: i64 = 0;
        while col < 15 {
            const idx = row * 15 + col;
            const tile = board.cells[idx];
            const pending = board.pending[idx];
            const committed = board.committed[idx];
            const selected = row == cursor_row and col == cursor_col;
            const slot_x = left + 4 + col * 2;
            const slot_y = top + row;
            const (fg, bg, bold) = cell_style(tile, pending, committed, selected, row, col, vga);
            const ch = match tile {
                0 => bonus_char(row, col);
                _ => letter_to_char(tile);
            };
            out = Canvas::put(out, slot_x, slot_y, ch, fg, bg, bold);
            col = col + 1;
        }
        row = row + 1;
    }

    const footer_y: i64 = gamekit::footer_y();
    const rack_y: i64 = footer_y - 4;
    out = Canvas::text(out, left + 2, rack_y - 1, "RACK", gamekit::palette_status(vga), gamekit::palette_bg(vga), true);
    let slot: i64 = 0;
    while slot < 7 {
        const tile = board.rack[slot];
        const x = left + 2 + slot * 4;
        const selected = slot == selected_slot;
        let base_fg = gamekit::palette_hud_text(vga);
        let base_bg = gamekit::palette_footer_bg(vga);
        if selected {
            base_fg = gamekit::palette_cursor_fg(vga);
            base_bg = gamekit::palette_cursor_bg(vga);
        }
        out = Canvas::text(out, x, rack_y, slot_label(slot), base_fg, base_bg, selected);
        out = Canvas::put(out, x + 1, rack_y, ':', base_fg, base_bg, false);
        if tile == 0 {
            out = Canvas::put(out, x + 2, rack_y, '-', gamekit::palette_dim_fg(vga), base_bg, false);
        } else {
            out = Canvas::put(out, x + 2, rack_y, letter_to_char(tile), base_fg, base_bg, true);
        }
        slot = slot + 1;
    }

    out
}

fn draw_row_label(canvas: Canvas, row: i64, left: i64, top: i64, vga: bool) -> Canvas {
    if row < 9 {
        return Canvas::text(canvas, left + 1, top + row, row_label(row), gamekit::palette_hud_text(vga), gamekit::palette_bg(vga), false);
    }
    Canvas::text(canvas, left, top + row, row_label(row), gamekit::palette_hud_text(vga), gamekit::palette_bg(vga), false)
}

fn draw_hud(canvas: Canvas, board: Board, elapsed_secs: i64, vga: bool) -> Canvas {
    const hud_x = 76;
    let out = Canvas::text(canvas, hud_x, 6, format!("SCORE: {}", board.score_total), gamekit::palette_hud_text(vga), gamekit::palette_bg(vga), true);
    out = Canvas::text(out, hud_x, 8, format!("LAST:  +{}", board.last_turn_score), gamekit::palette_hud_text(vga), gamekit::palette_bg(vga), false);
    out = Canvas::text(out, hud_x, 10, format!("BAG:   {}", board.bag_count), gamekit::palette_hud_text(vga), gamekit::palette_bg(vga), false);
    out = Canvas::text(out, hud_x, 12, format!("TURN:  {}", board.turn_number), gamekit::palette_hud_text(vga), gamekit::palette_bg(vga), false);
    out = Canvas::text(out, hud_x, 14, format!("TIME:  {}", format_elapsed_clock(elapsed_secs)), gamekit::palette_hud_text(vga), gamekit::palette_bg(vga), false);

    out = Canvas::text(out, hud_x, 18, "Premium squares", gamekit::palette_status(vga), gamekit::palette_bg(vga), true);
    out = Canvas::text(out, hud_x, 20, "* center (DW)", gamekit::palette_hud_text(vga), gamekit::palette_bg(vga), false);
    out = Canvas::text(out, hud_x, 21, "2 double letter", gamekit::palette_hud_text(vga), gamekit::palette_bg(vga), false);
    out = Canvas::text(out, hud_x, 22, "3 triple letter", gamekit::palette_hud_text(vga), gamekit::palette_bg(vga), false);
    out = Canvas::text(out, hud_x, 23, "= double word", gamekit::palette_hud_text(vga), gamekit::palette_bg(vga), false);
    out = Canvas::text(out, hud_x, 24, "# triple word", gamekit::palette_hud_text(vga), gamekit::palette_bg(vga), false);
    out
}

fn draw_control_hint(canvas: Canvas, vga: bool) -> Canvas {
    const footer_y: i64 = gamekit::footer_y();
    let out = Canvas::text(canvas, 4, footer_y - 2, "Scrabble UX: start at center, build one line per turn, c place, n lock-in, r undo turn", gamekit::palette_hud_text(vga), gamekit::palette_bg(vga), false);
    Canvas::text(out, 4, footer_y - 1, "h next tile, p shuffle, o sort by score, v terminal/sdl", gamekit::palette_hud_text(vga), gamekit::palette_bg(vga), false)
}

fn draw_quit_prompt(canvas: Canvas, vga: bool, quit_armed: bool) -> Canvas {
    if not quit_armed {
        return canvas;
    }
    const prompt_bg = gamekit::palette_footer_bg(vga);
    const prompt_fg = gamekit::palette_status(vga);
    const panel = Canvas::fill_rect(canvas, 24, 34, 72, 3, ' ', prompt_fg, prompt_bg, false);
    Canvas::text(panel, 27, 35, "Press q again to quit (any key cancels)", prompt_fg, prompt_bg, true)
}

fn cell_style(tile: i64, pending: bool, committed: bool, selected: bool, row: i64, col: i64, vga: bool) -> (i64, i64, bool) {
    let fg = gamekit::palette_hud_text(vga);
    let bg = bonus_bg(row, col, vga);
    let bold = false;

    if tile > 0 {
        if committed {
            fg = gamekit::palette_fixed_fg(vga);
            bg = gamekit::palette_fixed_bg(vga);
            bold = true;
        } else {
            if pending {
                fg = gamekit::palette_edit_fg(vga);
                bg = gamekit::palette_edit_bg(vga);
                bold = true;
            }
        }
    }

    if selected {
        fg = gamekit::palette_cursor_fg(vga);
        bg = gamekit::palette_cursor_bg(vga);
        bold = true;
    }
    (fg, bg, bold)
}

fn bonus_bg(row: i64, col: i64, vga: bool) -> i64 {
    const kind = bonus_kind(row, col);
    if kind == 4 {
        if vga {
            return 166;
        }
        return 173;
    }
    if kind == 3 {
        if vga {
            return 124;
        }
        return 160;
    }
    if kind == 2 {
        if vga {
            return 60;
        }
        return 63;
    }
    if kind == 1 {
        if vga {
            return 94;
        }
        return 109;
    }
    gamekit::palette_board_bg(vga)
}

fn bonus_char(row: i64, col: i64) -> char {
    if row == 7 and col == 7 {
        return '*';
    }
    match bonus_kind(row, col) {
        4 => '=';
        3 => '#';
        2 => '3';
        1 => '2';
        _ => '.';
    }
}

fn bonus_kind(row: i64, col: i64) -> i64 {
    if row == 7 and col == 7 {
        return 4;
    }
    if is_triple_word(row, col) {
        return 3;
    }
    if is_double_word(row, col) {
        return 4;
    }
    if is_triple_letter(row, col) {
        return 2;
    }
    if is_double_letter(row, col) {
        return 1;
    }
    0
}

fn is_triple_word(row: i64, col: i64) -> bool {
    is_any_coord(
        row,
        col,
        [
            0, 0,
            0, 7,
            0, 14,
            7, 0,
            7, 14,
            14, 0,
            14, 7,
            14, 14,
        ],
    )
}

fn is_double_word(row: i64, col: i64) -> bool {
    is_any_coord(
        row,
        col,
        [
            1, 1, 2, 2, 3, 3, 4, 4,
            10, 10, 11, 11, 12, 12, 13, 13,
            1, 13, 2, 12, 3, 11, 4, 10,
            10, 4, 11, 3, 12, 2, 13, 1,
        ],
    )
}

fn is_triple_letter(row: i64, col: i64) -> bool {
    is_any_coord(
        row,
        col,
        [
            1, 5, 1, 9,
            5, 1, 5, 5, 5, 9, 5, 13,
            9, 1, 9, 5, 9, 9, 9, 13,
            13, 5, 13, 9,
        ],
    )
}

fn is_double_letter(row: i64, col: i64) -> bool {
    is_any_coord(
        row,
        col,
        [
            0, 3, 0, 11,
            2, 6, 2, 8,
            3, 0, 3, 7, 3, 14,
            6, 2, 6, 6, 6, 8, 6, 12,
            7, 3, 7, 11,
            8, 2, 8, 6, 8, 8, 8, 12,
            11, 0, 11, 7, 11, 14,
            12, 6, 12, 8,
            14, 3, 14, 11,
        ],
    )
}

fn is_any_coord(row: i64, col: i64, pairs: Vec<i64>) -> bool {
    let expect_col = false;
    let candidate_row = -1;
    for value in pairs {
        if not expect_col {
            candidate_row = value;
            expect_col = true;
        } else {
            if candidate_row == row and value == col {
                return true;
            }
            expect_col = false;
        }
    }
    false
}

fn score_main_word(cells: Vec<i64>, pending: Vec<bool>, axis_code: i64, anchor: i64, span_start: i64, span_end: i64) -> (i64, i64) {
    if axis_code == 0 {
        return score_word(cells, pending, axis_code, anchor, span_start, span_end);
    }
    score_word(cells, pending, axis_code, anchor, span_start, span_end)
}

fn score_cross_word(cells: Vec<i64>, pending: Vec<bool>, axis_code: i64, row: i64, col: i64) -> (i64, i64) {
    if axis_code == 0 {
        // main move horizontal => cross vertical
        let start = row;
        let end = row;
        let cur = row;
        while cur > 0 and cells[(cur - 1) * 15 + col] > 0 {
            cur = cur - 1;
        }
        start = cur;
        cur = row;
        while cur < 14 and cells[(cur + 1) * 15 + col] > 0 {
            cur = cur + 1;
        }
        end = cur;
        return score_word(cells, pending, 1, col, start, end);
    }

    // main move vertical => cross horizontal
    let start = col;
    let end = col;
    let cur = col;
    while cur > 0 and cells[row * 15 + cur - 1] > 0 {
        cur = cur - 1;
    }
    start = cur;
    cur = col;
    while cur < 14 and cells[row * 15 + cur + 1] > 0 {
        cur = cur + 1;
    }
    end = cur;
    score_word(cells, pending, 0, row, start, end)
}

fn score_word(cells: Vec<i64>, pending: Vec<bool>, axis_code: i64, anchor: i64, start: i64, end: i64) -> (i64, i64) {
    if end < start {
        return (0, 0);
    }
    let sum = 0;
    let word_mult = 1;
    let len = end - start + 1;

    let step = start;
    while step <= end {
        let row = step;
        let col = anchor;
        if axis_code == 0 {
            row = anchor;
            col = step;
        }
        const idx = row * 15 + col;
        const tile = cells[idx];
        if tile == 0 {
            return (0, 0);
        }

        let letter_mult = 1;
        if pending[idx] {
            const kind = bonus_kind(row, col);
            if kind == 2 {
                letter_mult = 3;
            } else {
                if kind == 1 {
                    letter_mult = 2;
                } else {
                    if kind == 3 {
                        word_mult = i64::saturating_mul(word_mult, 3);
                    } else {
                        if kind == 4 {
                            word_mult = i64::saturating_mul(word_mult, 2);
                        }
                    }
                }
            }
        }
        const tile_points = i64::saturating_mul(letter_score(tile), letter_mult);
        sum = i64::saturating_add(sum, tile_points);
        step = step + 1;
    }

    (i64::saturating_mul(sum, word_mult), len)
}

fn placement_axis(pending_positions: Vec<i64>) -> (i64, i64, i64, i64) {
    const first = pending_positions[0];
    const first_row = first / 15;
    const first_col = first % 15;

    let same_row = true;
    let same_col = true;
    let min_row = first_row;
    let max_row = first_row;
    let min_col = first_col;
    let max_col = first_col;

    for pos in pending_positions {
        const row = pos / 15;
        const col = pos % 15;
        if row != first_row {
            same_row = false;
        }
        if col != first_col {
            same_col = false;
        }
        if row < min_row {
            min_row = row;
        }
        if row > max_row {
            max_row = row;
        }
        if col < min_col {
            min_col = col;
        }
        if col > max_col {
            max_col = col;
        }
    }

    if same_row {
        return (0, first_row, min_col, max_col);
    }
    if same_col {
        return (1, first_col, min_row, max_row);
    }
    (-1, 0, 0, 0)
}

fn placement_span_is_contiguous(cells: Vec<i64>, axis_code: i64, anchor: i64, start: i64, end: i64) -> bool {
    let step = start;
    while step <= end {
        let row = step;
        let col = anchor;
        if axis_code == 0 {
            row = anchor;
            col = step;
        }
        if cells[row * 15 + col] == 0 {
            return false;
        }
        step = step + 1;
    }
    true
}

fn pending_touches_center(pending: Vec<bool>) -> bool {
    pending[7 * 15 + 7]
}

fn pending_connects_to_committed(pending: Vec<bool>, committed: Vec<bool>) -> bool {
    let row = 0;
    while row < 15 {
        let col = 0;
        while col < 15 {
            const idx = row * 15 + col;
            if pending[idx] {
                if row > 0 and committed[(row - 1) * 15 + col] {
                    return true;
                }
                if row < 14 and committed[(row + 1) * 15 + col] {
                    return true;
                }
                if col > 0 and committed[row * 15 + col - 1] {
                    return true;
                }
                if col < 14 and committed[row * 15 + col + 1] {
                    return true;
                }
            }
            col = col + 1;
        }
        row = row + 1;
    }
    false
}

fn collect_pending_positions(pending: Vec<bool>) -> Vec<i64> {
    let positions: Vec<i64> = [];
    let idx = 0;
    while idx < board_area() {
        if pending[idx] {
            positions.push(idx);
        }
        idx = idx + 1;
    }
    positions
}

fn rank_tile_for_sort(tile: i64) -> i64 {
    if tile == 0 {
        return -1;
    }
    letter_score(tile) * 100 + (27 - tile)
}

fn letter_score(letter: i64) -> i64 {
    match letter {
        1 => 1;
        2 => 3;
        3 => 3;
        4 => 2;
        5 => 1;
        6 => 4;
        7 => 2;
        8 => 4;
        9 => 1;
        10 => 8;
        11 => 5;
        12 => 1;
        13 => 3;
        14 => 1;
        15 => 1;
        16 => 3;
        17 => 10;
        18 => 1;
        19 => 1;
        20 => 1;
        21 => 1;
        22 => 4;
        23 => 4;
        24 => 8;
        25 => 4;
        26 => 10;
        _ => 0;
    }
}

fn letter_to_char(letter: i64) -> char {
    match letter {
        1 => 'A';
        2 => 'B';
        3 => 'C';
        4 => 'D';
        5 => 'E';
        6 => 'F';
        7 => 'G';
        8 => 'H';
        9 => 'I';
        10 => 'J';
        11 => 'K';
        12 => 'L';
        13 => 'M';
        14 => 'N';
        15 => 'O';
        16 => 'P';
        17 => 'Q';
        18 => 'R';
        19 => 'S';
        20 => 'T';
        21 => 'U';
        22 => 'V';
        23 => 'W';
        24 => 'X';
        25 => 'Y';
        26 => 'Z';
        _ => '-';
    }
}

fn empty_rack() -> Vec<i64> {
    let rack: Vec<i64> = [];
    let idx = 0;
    while idx < 7 {
        rack.push(0);
        idx = idx + 1;
    }
    rack
}

fn next_random_index(seed: u64, max: i64) -> (u64, i64) {
    if max <= 0 {
        return (seed, 0);
    }
    const max_u64 = numeric::to_nonneg_u64(max);
    const next = numeric::prng_step(seed);
    const index_u64 = numeric::modulo_nonzero(next, max_u64);
    (next, numeric::to_i64_clamped(index_u64))
}

fn weighted_tile(value: i64) -> i64 {
    const slot = value % 98;
    if slot < 9 { return 1; }
    if slot < 11 { return 2; }
    if slot < 13 { return 3; }
    if slot < 17 { return 4; }
    if slot < 29 { return 5; }
    if slot < 31 { return 6; }
    if slot < 34 { return 7; }
    if slot < 36 { return 8; }
    if slot < 45 { return 9; }
    if slot < 46 { return 10; }
    if slot < 47 { return 11; }
    if slot < 51 { return 12; }
    if slot < 53 { return 13; }
    if slot < 59 { return 14; }
    if slot < 67 { return 15; }
    if slot < 69 { return 16; }
    if slot < 70 { return 17; }
    if slot < 76 { return 18; }
    if slot < 80 { return 19; }
    if slot < 86 { return 20; }
    if slot < 90 { return 21; }
    if slot < 92 { return 22; }
    if slot < 94 { return 23; }
    if slot < 95 { return 24; }
    if slot < 97 { return 25; }
    26
}

fn slot_label(slot: i64) -> String {
    match slot {
        0 => String::from("1");
        1 => String::from("2");
        2 => String::from("3");
        3 => String::from("4");
        4 => String::from("5");
        5 => String::from("6");
        _ => String::from("7");
    }
}

fn row_label(row: i64) -> String {
    match row {
        0 => String::from("1");
        1 => String::from("2");
        2 => String::from("3");
        3 => String::from("4");
        4 => String::from("5");
        5 => String::from("6");
        6 => String::from("7");
        7 => String::from("8");
        8 => String::from("9");
        9 => String::from("10");
        10 => String::from("11");
        11 => String::from("12");
        12 => String::from("13");
        13 => String::from("14");
        _ => String::from("15");
    }
}

fn board_index(row: i64, col: i64) -> i64 {
    if row < 0 or row >= board_size() {
        return -1;
    }
    if col < 0 or col >= board_size() {
        return -1;
    }
    row * board_size() + col
}

fn board_size() -> i64 {
    15
}

fn board_area() -> i64 {
    board_size() * board_size()
}

fn format_elapsed_clock(seconds: i64) -> String {
    if seconds < 0 {
        return String::from("00:00");
    }
    const mins = seconds / 60;
    const secs = seconds % 60;
    if mins < 10 {
        if secs < 10 {
            return format!("0{}:0{}", mins, secs);
        }
        return format!("0{}:{}", mins, secs);
    }
    if secs < 10 {
        return format!("{}:0{}", mins, secs);
    }
    format!("{}:{}", mins, secs)
}
