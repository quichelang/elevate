rust use crate::runtime_core;
rust use crate::model::Arg;
rust use crate::model::ParseError;

pub struct LongWithValue {
    name: String;
    value: String;
}

pub enum RawArgClass {
    DashDash;
    Long(String);
    LongWithValue(LongWithValue);
    ShortCluster(String);
    Value(String);
}

pub enum MaybeString {
    Some(String);
    None;
}

pub enum LongPrefixSplit {
    Long(String);
    Other(String);
}

pub enum ShortPrefixSplit {
    ShortCluster(String);
    Value(String);
}

pub enum LongEqSplit {
    WithValue(LongWithValue);
    Plain(String);
}

pub struct ClusterParts {
    short: String;
    rest: String;
}

pub struct ParserHandle {
    raw: i64;
}

pub enum ClusterSplit {
    End;
    UnexpectedValue(String);
    Short(ClusterParts);
}

pub fn from_env() -> i64 {
    runtime_core::from_env()
}

pub fn from_raw(raw: String) -> i64 {
    runtime_core::from_raw(raw)
}

pub fn from_env_handle() -> ParserHandle {
    ParserHandle { raw: from_env() }
}

pub fn from_raw_handle(raw: String) -> ParserHandle {
    ParserHandle { raw: from_raw(raw) }
}

pub fn handle_id(handle: ParserHandle) -> i64 {
    handle.raw
}

pub fn next(handle: i64) -> Result<Option<Arg>, ParseError> {
    next_internal(handle)
}

fn next_internal(handle: i64) -> Result<Option<Arg>, ParseError> {
    const pending = runtime_core::take_pending_value(handle);
    match pending {
        MaybeString::Some(value) => pending_unexpected_value(handle, value);
        MaybeString::None => next_after_pending(handle);
    }
}

fn pending_unexpected_value(handle: i64, value: String) -> Result<Option<Arg>, ParseError> {
    Result::Err(ParseError::UnexpectedValue(
        runtime_core::format_unexpected_value_for_last(handle, value),
    ))
}

fn next_after_pending(handle: i64) -> Result<Option<Arg>, ParseError> {
    const cluster = runtime_core::take_short_cluster(handle);
    match cluster {
        MaybeString::Some(cluster_text) => next_from_cluster(handle, cluster_text);
        MaybeString::None => next_from_stream(handle);
    }
}

fn next_from_cluster(handle: i64, cluster: String) -> Result<Option<Arg>, ParseError> {
    const split = split_cluster(cluster);
    match split {
        ClusterSplit::End => next_internal(handle);
        ClusterSplit::UnexpectedValue(value) => pending_unexpected_value(handle, value);
        ClusterSplit::Short(parts) => emit_short_from_parts(handle, parts);
    }
}

fn emit_short_from_parts(handle: i64, parts: ClusterParts) -> Result<Option<Arg>, ParseError> {
    runtime_core::set_short_cluster(handle, parts.rest);
    emit_short(handle, parts.short)
}

fn emit_short(handle: i64, short: String) -> Result<Option<Arg>, ParseError> {
    Result::Ok(Option::Some(runtime_core::finalize_short(handle, short)))
}

fn next_from_stream(handle: i64) -> Result<Option<Arg>, ParseError> {
    const next_arg = runtime_core::take_next_arg(handle);
    match next_arg {
        MaybeString::Some(arg) => next_from_taken_arg(handle, arg);
        MaybeString::None => Result::Ok(Option::None);
    }
}

fn next_from_taken_arg(handle: i64, arg: String) -> Result<Option<Arg>, ParseError> {
    if runtime_core::is_finished_opts(handle) {
        runtime_core::clear_last_option(handle);
        return Result::Ok(Option::Some(Arg::Value(arg)));
    }
    next_from_classified_arg(handle, arg)
}

fn next_from_classified_arg(handle: i64, arg: String) -> Result<Option<Arg>, ParseError> {
    const class = classify_arg(arg);
    match class {
        RawArgClass::DashDash => after_dashdash(handle);
        RawArgClass::Long(name) => emit_long(handle, name);
        RawArgClass::LongWithValue(payload) => emit_long_with_value(handle, payload);
        RawArgClass::ShortCluster(cluster) => continue_short_cluster(handle, cluster);
        RawArgClass::Value(value) => emit_value(handle, value);
    }
}

fn classify_arg(arg: String) -> RawArgClass {
    const long_split = split_long_prefix(arg);
    match long_split {
        LongPrefixSplit::Long(rest) => classify_long_rest(rest);
        LongPrefixSplit::Other(other) => classify_short_or_value(other);
    }
}

fn classify_long_rest(rest: String) -> RawArgClass {
    const maybe_text = nonempty_text(rest);
    match maybe_text {
        MaybeString::Some(text) => classify_nonempty_long(text);
        MaybeString::None => RawArgClass::DashDash;
    }
}

fn classify_nonempty_long(text: String) -> RawArgClass {
    const split = split_long_eq(text);
    match split {
        LongEqSplit::WithValue(payload) => RawArgClass::LongWithValue(payload);
        LongEqSplit::Plain(name) => RawArgClass::Long(name);
    }
}

fn classify_short_or_value(arg: String) -> RawArgClass {
    const short_split = split_short_prefix(arg);
    match short_split {
        ShortPrefixSplit::ShortCluster(cluster) => RawArgClass::ShortCluster(cluster);
        ShortPrefixSplit::Value(value) => RawArgClass::Value(value);
    }
}

fn after_dashdash(handle: i64) -> Result<Option<Arg>, ParseError> {
    runtime_core::set_finished_opts(handle);
    next_internal(handle)
}

fn emit_long(handle: i64, name: String) -> Result<Option<Arg>, ParseError> {
    Result::Ok(Option::Some(runtime_core::finalize_long(handle, name)))
}

fn emit_long_with_value(
    handle: i64,
    payload: LongWithValue,
) -> Result<Option<Arg>, ParseError> {
    Result::Ok(Option::Some(runtime_core::finalize_long_with_value(handle, payload)))
}

fn continue_short_cluster(handle: i64, cluster: String) -> Result<Option<Arg>, ParseError> {
    runtime_core::set_short_cluster(handle, cluster);
    next_internal(handle)
}

fn emit_value(handle: i64, value: String) -> Result<Option<Arg>, ParseError> {
    runtime_core::clear_last_option(handle);
    Result::Ok(Option::Some(Arg::Value(value)))
}

pub fn value(handle: i64) -> Result<String, ParseError> {
    const maybe = optional_value_internal(handle);
    match maybe {
        MaybeString::Some(value) => Result::Ok(value);
        MaybeString::None => value_from_stream_or_error(handle);
    }
}

fn value_from_stream_or_error(handle: i64) -> Result<String, ParseError> {
    const raw_next = runtime_core::take_next_arg(handle);
    match raw_next {
        MaybeString::Some(value) => Result::Ok(value);
        MaybeString::None => Result::Err(ParseError::MissingValue(
            runtime_core::format_missing_value_for_last(handle),
        ));
    }
}

pub fn optional_value(handle: i64) -> Option<String> {
    maybe_to_option(optional_value_internal(handle))
}

fn optional_value_internal(handle: i64) -> MaybeString {
    const pending = runtime_core::take_pending_value(handle);
    match pending {
        MaybeString::Some(value) => MaybeString::Some(value);
        MaybeString::None => optional_from_cluster(handle);
    }
}

fn optional_from_cluster(handle: i64) -> MaybeString {
    const cluster = runtime_core::take_short_cluster(handle);
    match cluster {
        MaybeString::Some(text) => MaybeString::Some(cluster_optional_value(text));
        MaybeString::None => MaybeString::None;
    }
}

pub fn values(handle: i64) -> Result<Option<String>, ParseError> {
    const maybe = optional_value_internal(handle);
    match maybe {
        MaybeString::Some(value) => Result::Ok(Option::Some(value));
        MaybeString::None => values_from_stream_or_error(handle);
    }
}

fn values_from_stream_or_error(handle: i64) -> Result<Option<String>, ParseError> {
    const peeked = runtime_core::peek_next_arg(handle);
    match peeked {
        MaybeString::Some(candidate) => values_from_candidate(handle, candidate);
        MaybeString::None => missing_value_result(handle);
    }
}

fn values_from_candidate(handle: i64, candidate: String) -> Result<Option<String>, ParseError> {
    if runtime_core::is_finished_opts(handle) {
        runtime_core::take_next_arg(handle);
        return Result::Ok(Option::Some(candidate));
    }

    const class = classify_arg(candidate);
    match class {
        RawArgClass::Value(value) => consume_and_return_value(handle, value);
        _ => missing_value_result(handle);
    }
}

fn consume_and_return_value(handle: i64, value: String) -> Result<Option<String>, ParseError> {
    runtime_core::take_next_arg(handle);
    Result::Ok(Option::Some(value))
}

fn missing_value_result(handle: i64) -> Result<Option<String>, ParseError> {
    Result::Err(ParseError::MissingValue(
        runtime_core::format_missing_value_for_last(handle),
    ))
}

fn maybe_to_option(value: MaybeString) -> Option<String> {
    match value {
        MaybeString::Some(text) => Option::Some(text);
        MaybeString::None => Option::None;
    }
}

pub fn reset(handle: i64) {
    runtime_core::reset(handle);
}

pub fn reset_handle(handle: ParserHandle) {
    reset(handle.raw);
}

pub fn next_handle(handle: ParserHandle) -> Result<Option<Arg>, ParseError> {
    next(handle.raw)
}

pub fn value_handle(handle: ParserHandle) -> Result<String, ParseError> {
    value(handle.raw)
}

pub fn optional_value_handle(handle: ParserHandle) -> Option<String> {
    optional_value(handle.raw)
}

pub fn values_handle(handle: ParserHandle) -> Result<Option<String>, ParseError> {
    values(handle.raw)
}

fn split_long_prefix(arg: String) -> LongPrefixSplit {
    if arg.starts_with("--") {
        return LongPrefixSplit::Long(str::strip_prefix_known(arg, "--"));
    }
    LongPrefixSplit::Other(arg)
}

fn nonempty_text(text: String) -> MaybeString {
    if text.is_empty() {
        return MaybeString::None;
    }
    MaybeString::Some(text)
}

fn split_long_eq(text: String) -> LongEqSplit {
    if text.contains("=") {
        const (name, value) = str::split_once_known(text, "=");
        return LongEqSplit::WithValue(LongWithValue {
            name: name;
            value: value;
        });
    }
    LongEqSplit::Plain(text)
}

fn split_short_prefix(arg: String) -> ShortPrefixSplit {
    if arg == "-" {
        return ShortPrefixSplit::Value(arg);
    }

    if arg.starts_with("-") {
        return ShortPrefixSplit::ShortCluster(str::strip_prefix_known(arg, "-"));
    }
    ShortPrefixSplit::Value(arg)
}

fn split_cluster(cluster: String) -> ClusterSplit {
    if cluster.is_empty() {
        return ClusterSplit::End;
    }

    if cluster.starts_with("=") {
        return ClusterSplit::UnexpectedValue(str::strip_prefix_known(cluster, "="));
    }
    split_cluster_short(cluster)
}

fn split_cluster_short(cluster: String) -> ClusterSplit {
    const (short, rest) = runtime_core::drop_first_char_known(cluster);
    ClusterSplit::Short(ClusterParts {
        short: short;
        rest: rest;
    })
}

fn cluster_optional_value(cluster: String) -> String {
    if cluster.starts_with("=") {
        return str::strip_prefix_known(cluster, "=");
    }
    cluster
}
