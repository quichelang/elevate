rust use crate::runtime;
rust use crate::model::Arg;
rust use crate::model::ParseError;

pub struct LongWithValue {
    name: String;
    value: String;
}

pub enum RawArgClass {
    DashDash;
    Long(String);
    LongWithValue(LongWithValue);
    ShortCluster(String);
    Value(String);
}

pub enum MaybeString {
    Some(String);
    None;
}

pub enum LongPrefixSplit {
    Long(String);
    Other(String);
}

pub enum ShortPrefixSplit {
    ShortCluster(String);
    Value(String);
}

pub enum LongEqSplit {
    WithValue(LongWithValue);
    Plain(String);
}

pub struct ClusterParts {
    short: String;
    rest: String;
}

pub enum ClusterSplit {
    End;
    UnexpectedValue(String);
    Short(ClusterParts);
}

pub fn from_env() -> i64 {
    runtime::from_env()
}

pub fn from_raw(raw: String) -> i64 {
    runtime::from_raw(raw)
}

pub fn next(handle: i64) -> Result<Option<Arg>, ParseError> {
    next_internal(handle)
}

fn next_internal(handle: i64) -> Result<Option<Arg>, ParseError> {
    const pending = runtime::take_pending_value(handle);
    match pending {
        MaybeString::Some(value) => pending_unexpected_value(handle, value);
        MaybeString::None => next_after_pending(handle);
    }
}

fn pending_unexpected_value(handle: i64, value: String) -> Result<Option<Arg>, ParseError> {
    Result::Err(ParseError::UnexpectedValue(
        runtime::format_unexpected_value_for_last(handle, value),
    ))
}

fn next_after_pending(handle: i64) -> Result<Option<Arg>, ParseError> {
    const cluster = runtime::take_short_cluster(handle);
    match cluster {
        MaybeString::Some(cluster_text) => next_from_cluster(handle, cluster_text);
        MaybeString::None => next_from_stream(handle);
    }
}

fn next_from_cluster(handle: i64, cluster: String) -> Result<Option<Arg>, ParseError> {
    const split = runtime::split_cluster(cluster);
    match split {
        ClusterSplit::End => next_internal(handle);
        ClusterSplit::UnexpectedValue(value) => pending_unexpected_value(handle, value);
        ClusterSplit::Short(parts) => emit_short_from_parts(handle, parts);
    }
}

fn emit_short_from_parts(handle: i64, parts: ClusterParts) -> Result<Option<Arg>, ParseError> {
    runtime::set_short_cluster(handle, parts.rest);
    emit_short(handle, parts.short)
}

fn emit_short(handle: i64, short: String) -> Result<Option<Arg>, ParseError> {
    Result::Ok(Option::Some(runtime::finalize_short(handle, short)))
}

fn next_from_stream(handle: i64) -> Result<Option<Arg>, ParseError> {
    const next_arg = runtime::take_next_arg(handle);
    match next_arg {
        MaybeString::Some(arg) => next_from_taken_arg(handle, arg);
        MaybeString::None => Result::Ok(Option::None);
    }
}

fn next_from_taken_arg(handle: i64, arg: String) -> Result<Option<Arg>, ParseError> {
    if runtime::is_finished_opts(handle) {
        runtime::clear_last_option(handle);
        return Result::Ok(Option::Some(Arg::Value(arg)));
    }
    next_from_classified_arg(handle, arg)
}

fn next_from_classified_arg(handle: i64, arg: String) -> Result<Option<Arg>, ParseError> {
    const class = classify_arg(arg);
    match class {
        RawArgClass::DashDash => after_dashdash(handle);
        RawArgClass::Long(name) => emit_long(handle, name);
        RawArgClass::LongWithValue(payload) => emit_long_with_value(handle, payload);
        RawArgClass::ShortCluster(cluster) => continue_short_cluster(handle, cluster);
        RawArgClass::Value(value) => emit_value(handle, value);
    }
}

fn classify_arg(arg: String) -> RawArgClass {
    const long_split = runtime::split_long_prefix(arg);
    match long_split {
        LongPrefixSplit::Long(rest) => classify_long_rest(rest);
        LongPrefixSplit::Other(other) => classify_short_or_value(other);
    }
}

fn classify_long_rest(rest: String) -> RawArgClass {
    const maybe_text = runtime::nonempty_text(rest);
    match maybe_text {
        MaybeString::Some(text) => classify_nonempty_long(text);
        MaybeString::None => RawArgClass::DashDash;
    }
}

fn classify_nonempty_long(text: String) -> RawArgClass {
    const split = runtime::split_long_eq(text);
    match split {
        LongEqSplit::WithValue(payload) => RawArgClass::LongWithValue(payload);
        LongEqSplit::Plain(name) => RawArgClass::Long(name);
    }
}

fn classify_short_or_value(arg: String) -> RawArgClass {
    const short_split = runtime::split_short_prefix(arg);
    match short_split {
        ShortPrefixSplit::ShortCluster(cluster) => RawArgClass::ShortCluster(cluster);
        ShortPrefixSplit::Value(value) => RawArgClass::Value(value);
    }
}

fn after_dashdash(handle: i64) -> Result<Option<Arg>, ParseError> {
    runtime::set_finished_opts(handle);
    next_internal(handle)
}

fn emit_long(handle: i64, name: String) -> Result<Option<Arg>, ParseError> {
    Result::Ok(Option::Some(runtime::finalize_long(handle, name)))
}

fn emit_long_with_value(
    handle: i64,
    payload: LongWithValue,
) -> Result<Option<Arg>, ParseError> {
    Result::Ok(Option::Some(runtime::finalize_long_with_value(handle, payload)))
}

fn continue_short_cluster(handle: i64, cluster: String) -> Result<Option<Arg>, ParseError> {
    runtime::set_short_cluster(handle, cluster);
    next_internal(handle)
}

fn emit_value(handle: i64, value: String) -> Result<Option<Arg>, ParseError> {
    runtime::clear_last_option(handle);
    Result::Ok(Option::Some(Arg::Value(value)))
}

pub fn value(handle: i64) -> Result<String, ParseError> {
    const maybe = optional_value_internal(handle);
    match maybe {
        MaybeString::Some(value) => Result::Ok(value);
        MaybeString::None => value_from_stream_or_error(handle);
    }
}

fn value_from_stream_or_error(handle: i64) -> Result<String, ParseError> {
    const raw_next = runtime::take_next_arg(handle);
    match raw_next {
        MaybeString::Some(value) => Result::Ok(value);
        MaybeString::None => Result::Err(ParseError::MissingValue(
            runtime::format_missing_value_for_last(handle),
        ));
    }
}

pub fn optional_value(handle: i64) -> Option<String> {
    maybe_to_option(optional_value_internal(handle))
}

fn optional_value_internal(handle: i64) -> MaybeString {
    const pending = runtime::take_pending_value(handle);
    match pending {
        MaybeString::Some(value) => MaybeString::Some(value);
        MaybeString::None => optional_from_cluster(handle);
    }
}

fn optional_from_cluster(handle: i64) -> MaybeString {
    const cluster = runtime::take_short_cluster(handle);
    match cluster {
        MaybeString::Some(text) => MaybeString::Some(runtime::cluster_optional_value(text));
        MaybeString::None => MaybeString::None;
    }
}

pub fn values(handle: i64) -> Result<Option<String>, ParseError> {
    const maybe = optional_value_internal(handle);
    match maybe {
        MaybeString::Some(value) => Result::Ok(Option::Some(value));
        MaybeString::None => values_from_stream_or_error(handle);
    }
}

fn values_from_stream_or_error(handle: i64) -> Result<Option<String>, ParseError> {
    const peeked = runtime::peek_next_arg(handle);
    match peeked {
        MaybeString::Some(candidate) => values_from_candidate(handle, candidate);
        MaybeString::None => missing_value_result(handle);
    }
}

fn values_from_candidate(handle: i64, candidate: String) -> Result<Option<String>, ParseError> {
    if runtime::is_finished_opts(handle) {
        runtime::take_next_arg(handle);
        return Result::Ok(Option::Some(candidate));
    }

    const class = classify_arg(candidate);
    match class {
        RawArgClass::Value(value) => consume_and_return_value(handle, value);
        _ => missing_value_result(handle);
    }
}

fn consume_and_return_value(handle: i64, value: String) -> Result<Option<String>, ParseError> {
    runtime::take_next_arg(handle);
    Result::Ok(Option::Some(value))
}

fn missing_value_result(handle: i64) -> Result<Option<String>, ParseError> {
    Result::Err(ParseError::MissingValue(
        runtime::format_missing_value_for_last(handle),
    ))
}

fn maybe_to_option(value: MaybeString) -> Option<String> {
    match value {
        MaybeString::Some(text) => Option::Some(text);
        MaybeString::None => Option::None;
    }
}

pub fn reset(handle: i64) {
    runtime::reset(handle);
}
