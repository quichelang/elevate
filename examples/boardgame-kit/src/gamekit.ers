use crate::gfx::Canvas;

pub struct Rect {
    x: i64;
    y: i64;
    width: i64;
    height: i64;
}

pub struct SceneLayout {
    board_left: i64;
    board_top: i64;
    board_width: i64;
    board_height: i64;
    hud_left: i64;
    hud_top: i64;
    hud_width: i64;
    footer_y: i64;
}

pub struct Sprite {
    width: i64;
    height: i64;
    pixels: Vec<char>;
}

pub struct SpriteLayer {
    z: i64;
    x: i64;
    y: i64;
    sprite: Sprite;
}

pub struct TileDef {
    key: String;
    sprite_id: i64;
}

pub struct TileAtlas {
    tiles: Vec<TileDef>;
}

pub struct AnimatedSprite {
    frame_ids: Vec<i64>;
    frame_durations_ms: Vec<i64>;
    looped: bool;
}

pub fn make_rect(x: i64, y: i64, width: i64, height: i64) -> Rect {
    Rect {
        x: x;
        y: y;
        width: width;
        height: height;
    }
}

pub fn sprite_layer(z: i64, x: i64, y: i64, sprite: Sprite) -> SpriteLayer {
    SpriteLayer {
        z: z;
        x: x;
        y: y;
        sprite: sprite;
    }
}

pub fn tile_atlas_new() -> TileAtlas {
    TileAtlas { tiles: [] }
}

pub fn tile_atlas_insert(atlas: TileAtlas, key: String, sprite_id: i64) -> TileAtlas {
    atlas.tiles.push(TileDef {
        key: key;
        sprite_id: sprite_id;
    });
    atlas
}

pub fn tile_atlas_lookup(atlas: TileAtlas, key: String) -> (TileAtlas, Option<i64>) {
    std::mem::drop(key);
    (atlas, Option::None)
}

pub fn blit_tile_key(
    canvas: Canvas,
    atlas: TileAtlas,
    key: String,
    x: i64,
    y: i64,
    vga: bool,
) -> (Canvas, TileAtlas) {
    const (next_atlas, sprite_id) = tile_atlas_lookup(atlas, key);
    const next_canvas = match sprite_id {
        Option::Some(id) => blit_palette_sprite(canvas, sprite_by_id(id), x, y, vga);
        Option::None => canvas;
    };
    (next_canvas, next_atlas)
}

pub fn animated_sprite(frame_ids: Vec<i64>, frame_durations_ms: Vec<i64>, looped: bool) -> AnimatedSprite {
    AnimatedSprite {
        frame_ids: frame_ids;
        frame_durations_ms: frame_durations_ms;
        looped: looped;
    }
}

pub fn animated_sprite_frame_id(anim: AnimatedSprite, clock_ms: i64) -> (AnimatedSprite, i64) {
    std::mem::drop(clock_ms);
    (anim, 0)
}

fn sprite_by_id(sprite_id: i64) -> Sprite {
    std::mem::drop(sprite_id);
    sprite_cloud()
}

pub fn sprite_from_rows(rows: Vec<String>) -> Sprite {
    let width = 0;
    let height = 0;
    let pixels: Vec<char> = [];
    for row_text in rows {
        let row_width = 0;
        for ch in row_text.chars() {
            if height == 0 or row_width < width {
                pixels.push(ch);
                row_width += 1;
            }
        }
        if height == 0 {
            width = row_width;
        }
        for _ in row_width..width {
            pixels.push(' ');
        }
        height += 1;
    }
    Sprite {
        width: width;
        height: height;
        pixels: pixels;
    }
}

pub fn render_sprite_layers(canvas: Canvas, layers: Vec<SpriteLayer>, vga: bool) -> Canvas {
    let out = canvas;
    for layer in layers {
        std::mem::drop(layer.z);
        out = blit_palette_sprite(out, layer.sprite, layer.x, layer.y, vga);
    }
    out
}

pub fn scene_layout() -> SceneLayout {
    SceneLayout {
        board_left: 13;
        board_top: 12;
        board_width: 37;
        board_height: 19;
        hud_left: 74;
        hud_top: 13;
        hud_width: 34;
        footer_y: 38;
    }
}

pub fn board_left() -> i64 {
    scene_layout().board_left
}

pub fn board_top() -> i64 {
    scene_layout().board_top
}

pub fn board_width() -> i64 {
    scene_layout().board_width
}

pub fn board_height() -> i64 {
    scene_layout().board_height
}

pub fn footer_y() -> i64 {
    scene_layout().footer_y
}

pub fn draw_scene_shell(
    canvas: Canvas,
    mode_label: String,
    status: String,
    debug_enabled: bool,
    fps: i64,
    vga: bool,
) -> Canvas {
    const layout = scene_layout();
    const sky_base = fill_gradient(
        canvas,
        make_rect(0, 0, 120, 11),
        palette_text(vga),
        palette_sky_top(vga),
        palette_sky_bottom(vga),
    );
    let sprite_layers: Vec<SpriteLayer> = [];
    sprite_layers.push(sprite_layer(0, 7, 1, sprite_cloud()));
    sprite_layers.push(sprite_layer(0, 42, 2, sprite_cloud()));
    sprite_layers.push(sprite_layer(0, 82, 1, sprite_cloud()));
    sprite_layers.push(sprite_layer(1, 4, 1, sprite_score_plaque(true)));
    sprite_layers.push(sprite_layer(1, 41, 1, sprite_score_plaque(false)));
    const sky = render_sprite_layers(sky_base, sprite_layers, vga);
    const sky_with_labels = Canvas::text(sky, 10, 2, "PLAYER 1", palette_title(vga), palette_panel_fill(vga), true);
    const sky_with_score_left = Canvas::text(sky_with_labels, 14, 3, "34", palette_title(vga), palette_panel_fill(vga), true);
    const sky_with_cpu = Canvas::text(sky_with_score_left, 47, 2, "CPU", palette_title(vga), palette_panel_fill(vga), true);
    const sky_with_scores = Canvas::text(sky_with_cpu, 49, 3, "28", palette_title(vga), palette_panel_fill(vga), true);

    const hills = draw_hills_band(sky_with_scores, make_rect(0, 4, 120, 9), vga);
    const deck_base = fill_gradient(
        hills,
        make_rect(0, 10, 120, 4),
        palette_text(vga),
        palette_wood_mid(vga),
        palette_wood_dark(vga),
    );
    const deck = render_sprite_layers(deck_base, deck_trim_layers(), vga);
    const floor_base = draw_brick_floor(deck, make_rect(0, 34, 120, 8), vga);
    const floor = render_sprite_layers(floor_base, floor_trim_layers(), vga);

    const top_bar = draw_bevel_panel(
        floor,
        make_rect(2, 1, 58, 3),
        palette_panel_light(vga),
        palette_panel_dark(vga),
        palette_panel_fill(vga),
    );
    const top_bar_title = Canvas::text(
        top_bar,
        4,
        2,
        format!("NEON BOARDWALK :: {} MODE", mode_label),
        palette_title(vga),
        palette_panel_fill(vga),
        true,
    );

    const board_frame = draw_wood_frame(
        top_bar_title,
        make_rect(layout.board_left - 5, layout.board_top - 4, layout.board_width + 10, layout.board_height + 8),
        vga,
    );
    const board_inner = Canvas::fill_rect(
        board_frame,
        layout.board_left - 1,
        layout.board_top - 1,
        layout.board_width + 2,
        layout.board_height + 2,
        ' ',
        palette_text(vga),
        palette_board_parchment(vga),
        false,
    );

    const hud_shell = draw_wood_frame(
        board_inner,
        make_rect(layout.hud_left - 2, layout.hud_top - 3, layout.hud_width, 24),
        vga,
    );
    const hud = draw_hud_panel(hud_shell, layout, status, debug_enabled, fps, vga);
    draw_footer_strip(hud, layout, vga)
}

pub fn draw_footer_status(canvas: Canvas, message: String, vga: bool) -> Canvas {
    const layout = scene_layout();
    const band = Canvas::fill_rect(
        canvas,
        2,
        layout.footer_y,
        116,
        3,
        ' ',
        palette_text(vga),
        palette_footer_bg(vga),
        false,
    );
    const label = Canvas::text(band, 4, layout.footer_y + 1, "Status:", palette_status(vga), palette_footer_bg(vga), true);
    Canvas::text(label, 13, layout.footer_y + 1, message, palette_hud_text(vga), palette_footer_bg(vga), false)
}

pub fn draw_gameplay_hints(canvas: Canvas, vga: bool) -> Canvas {
    const layout = scene_layout();
    const line1 = Canvas::text(
        canvas,
        4,
        layout.footer_y - 2,
        "Controls: arrows/WASD move | 1-9 set | 0/space/backspace clear",
        palette_hud_text(vga),
        palette_bg(vga),
        false,
    );
    Canvas::text(
        line1,
        4,
        layout.footer_y - 1,
        "          c check | n next | r reset | v renderer | g debug | q quit",
        palette_hud_text(vga),
        palette_bg(vga),
        false,
    )
}

fn blit_palette_sprite(canvas: Canvas, sprite: Sprite, x: i64, y: i64, vga: bool) -> Canvas {
    let out = canvas;
    if sprite.width <= 0 or sprite.height <= 0 {
        return out;
    }
    for row in 0..sprite.height {
        for col in 0..sprite.width {
            const idx = row * sprite.width + col;
            const token = sprite.pixels[idx];
            const (draw, glyph, fg, bg, bold) = sprite_style(token, vga);
            if draw {
                out = Canvas::put(out, x + col, y + row, glyph, fg, bg, bold);
            }
        }
    }
    out
}

fn sprite_style(token: char, vga: bool) -> (bool, char, i64, i64, bool) {
    match token {
        ' ' => (false, ' ', 0, 0, false);
        '~' => (true, ' ', palette_text(vga), palette_sky_bottom(vga), false);
        '.' => (true, ' ', palette_text(vga), palette_sky_top(vga), false);
        '#' => (true, ' ', palette_text(vga), palette_wood_dark(vga), false);
        '=' => (true, ' ', palette_text(vga), palette_wood_mid(vga), false);
        '+' => (true, ' ', palette_text(vga), palette_wood_light(vga), false);
        '*' => (true, '*', palette_title(vga), palette_panel_fill(vga), true);
        '@' => (true, '@', palette_hud_text(vga), palette_panel_fill(vga), true);
        _ => (true, token, palette_hud_text(vga), palette_panel_fill(vga), true);
    }
}

fn deck_trim_layers() -> Vec<SpriteLayer> {
    let layers: Vec<SpriteLayer> = [];
    layers.push(sprite_layer(0, 0, 10, sprite_horizontal_trim(120, '#')));
    layers.push(sprite_layer(1, 0, 11, sprite_horizontal_trim(120, '=')));
    layers.push(sprite_layer(0, 0, 13, sprite_horizontal_trim(120, '#')));
    layers
}

fn floor_trim_layers() -> Vec<SpriteLayer> {
    let layers: Vec<SpriteLayer> = [];
    layers.push(sprite_layer(0, 0, 33, sprite_horizontal_trim(120, '#')));
    layers
}

fn sprite_horizontal_trim(width: i64, ch: char) -> Sprite {
    let pixels: Vec<char> = [];
    for _ in 0..width {
        pixels.push(ch);
    }
    Sprite {
        width: width;
        height: 1;
        pixels: pixels;
    }
}

fn sprite_cloud() -> Sprite {
    let rows: Vec<String> = [];
    rows.push(String::from("   ..~~~~~~..   "));
    rows.push(String::from(" ..~~~~~~~~~~.. "));
    rows.push(String::from("..~~~~~~~~~~~~.."));
    sprite_from_rows(rows)
}

fn sprite_score_plaque(player_one: bool) -> Sprite {
    const top = String::from("+##########+");
    const mid = String::from("#++++++++++#");
    let rows: Vec<String> = [];
    if player_one {
        rows.push(top);
        rows.push(String::from("#++@@@@@++++#"));
        rows.push(mid);
        rows.push(String::from("+##########+"));
        return sprite_from_rows(rows);
    }
    rows.push(top);
    rows.push(String::from("#++++@@@++++#"));
    rows.push(mid);
    rows.push(String::from("+##########+"));
    sprite_from_rows(rows)
}

pub fn palette_bg(vga: bool) -> i64 {
    if vga {
        return 16;
    }
    16
}

pub fn palette_board_bg(vga: bool) -> i64 {
    if vga {
        return 94;
    }
    230
}

pub fn palette_board_parchment(vga: bool) -> i64 {
    if vga {
        return 180;
    }
    223
}

pub fn palette_grid_major(vga: bool) -> i64 {
    if vga {
        return 130;
    }
    94
}

pub fn palette_grid_minor(vga: bool) -> i64 {
    if vga {
        return 137;
    }
    136
}

pub fn palette_fixed_fg(vga: bool) -> i64 {
    if vga {
        return 19;
    }
    18
}

pub fn palette_fixed_bg(vga: bool) -> i64 {
    if vga {
        return 229;
    }
    223
}

pub fn palette_edit_fg(vga: bool) -> i64 {
    if vga {
        return 24;
    }
    25
}

pub fn palette_edit_bg(vga: bool) -> i64 {
    if vga {
        return 230;
    }
    229
}

pub fn palette_cursor_fg(vga: bool) -> i64 {
    if vga {
        return 16;
    }
    16
}

pub fn palette_cursor_bg(vga: bool) -> i64 {
    if vga {
        return 220;
    }
    214
}

pub fn palette_conflict_fg(vga: bool) -> i64 {
    if vga {
        return 231;
    }
    231
}

pub fn palette_conflict_bg(vga: bool) -> i64 {
    if vga {
        return 124;
    }
    124
}

pub fn palette_dim_fg(vga: bool) -> i64 {
    if vga {
        return 101;
    }
    101
}

pub fn palette_hud_text(vga: bool) -> i64 {
    if vga {
        return 230;
    }
    229
}

pub fn palette_status(vga: bool) -> i64 {
    if vga {
        return 220;
    }
    220
}

pub fn palette_debug_fg(vga: bool) -> i64 {
    if vga {
        return 47;
    }
    47
}

pub fn palette_debug_bg(vga: bool) -> i64 {
    if vga {
        return 18;
    }
    18
}

pub fn palette_board_shadow(vga: bool) -> i64 {
    if vga {
        return 52;
    }
    52
}

pub fn palette_text(vga: bool) -> i64 {
    if vga {
        return 230;
    }
    230
}

fn palette_sky_top(vga: bool) -> i64 {
    if vga {
        return 20;
    }
    18
}

fn palette_sky_bottom(vga: bool) -> i64 {
    if vga {
        return 39;
    }
    33
}

fn palette_wood_dark(vga: bool) -> i64 {
    if vga {
        return 52;
    }
    52
}

fn palette_wood_mid(vga: bool) -> i64 {
    if vga {
        return 94;
    }
    94
}

fn palette_wood_light(vga: bool) -> i64 {
    if vga {
        return 136;
    }
    136
}

fn palette_panel_light(vga: bool) -> i64 {
    if vga {
        return 179;
    }
    179
}

fn palette_panel_dark(vga: bool) -> i64 {
    if vga {
        return 94;
    }
    94
}

fn palette_panel_fill(vga: bool) -> i64 {
    if vga {
        return 58;
    }
    58
}

fn palette_title(vga: bool) -> i64 {
    if vga {
        return 229;
    }
    229
}

fn palette_footer_bg(vga: bool) -> i64 {
    if vga {
        return 235;
    }
    235
}

fn fill_gradient(canvas: Canvas, rect: Rect, fg: i64, top_bg: i64, bottom_bg: i64) -> Canvas {
    if rect.height <= 0 {
        return canvas;
    }
    for row in 0..rect.height {
        const bg = blend_band(top_bg, bottom_bg, row, rect.height);
        canvas = Canvas::fill_rect(canvas, rect.x, rect.y + row, rect.width, 1, ' ', fg, bg, false);
    }
    canvas
}

fn draw_hills_band(canvas: Canvas, rect: Rect, vga: bool) -> Canvas {
    const hill_a = palette_hill_a(vga);
    const hill_b = palette_hill_b(vga);
    const hill_c = palette_hill_c(vga);
    for row in 0..rect.height {
        for col in 0..rect.width {
            const wave_a = ((col + row * 2) % 19) < 10;
            const wave_b = ((col * 2 + row * 3 + 7) % 23) < 11;
            const bg = match wave_a and wave_b {
                true => hill_c;
                false => match wave_a {
                    true => hill_b;
                    false => hill_a;
                };
            };
            const y = rect.y + row;
            const x = rect.x + col;
            if y >= rect.y + 2 {
                canvas = Canvas::put(canvas, x, y, ' ', palette_text(vga), bg, false);
            }
        }
    }
    canvas
}

fn draw_brick_floor(canvas: Canvas, rect: Rect, vga: bool) -> Canvas {
    const brick_a = palette_brick_a(vga);
    const brick_b = palette_brick_b(vga);
    const brick_c = palette_brick_c(vga);
    for row in 0..rect.height {
        for col in 0..rect.width {
            const x = rect.x + col;
            const y = rect.y + row;
            const block = ((col / 4) + (row / 2)) % 3;
            const bg = match block {
                0 => brick_a;
                1 => brick_b;
                _ => brick_c;
            };
            const mortar = row % 2 == 0 or col % 4 == 0;
            const ch = match mortar {
                true => '.';
                false => ' ';
            };
            const fg = match mortar {
                true => palette_wood_dark(vga);
                false => palette_text(vga);
            };
            canvas = Canvas::put(canvas, x, y, ch, fg, bg, false);
        }
    }
    canvas
}

fn draw_wood_frame(canvas: Canvas, rect: Rect, vga: bool) -> Canvas {
    const outer = Canvas::fill_rect(canvas, rect.x, rect.y, rect.width, rect.height, ' ', palette_text(vga), palette_wood_dark(vga), false);
    const middle = Canvas::fill_rect(outer, rect.x + 1, rect.y + 1, rect.width - 2, rect.height - 2, ' ', palette_text(vga), palette_wood_mid(vga), false);
    const inner = Canvas::fill_rect(middle, rect.x + 2, rect.y + 2, rect.width - 4, rect.height - 4, ' ', palette_text(vga), palette_wood_light(vga), false);
    draw_bevel_panel(
        inner,
        make_rect(rect.x + 2, rect.y + 2, rect.width - 4, rect.height - 4),
        palette_panel_light(vga),
        palette_wood_dark(vga),
        palette_wood_light(vga),
    )
}

fn draw_bevel_panel(canvas: Canvas, rect: Rect, light: i64, dark: i64, fill: i64) -> Canvas {
    const fill_canvas = Canvas::fill_rect(canvas, rect.x, rect.y, rect.width, rect.height, ' ', 230, fill, false);
    const top = Canvas::hline(fill_canvas, rect.x, rect.y, rect.width, '=', light, fill, true);
    const left = Canvas::vline(top, rect.x, rect.y, rect.height, '|', light, fill, true);
    const right = Canvas::vline(left, rect.x + rect.width - 1, rect.y, rect.height, '|', dark, fill, true);
    Canvas::hline(right, rect.x, rect.y + rect.height - 1, rect.width, '=', dark, fill, true)
}

fn draw_hud_panel(
    canvas: Canvas,
    layout: SceneLayout,
    status: String,
    debug_enabled: bool,
    fps: i64,
    vga: bool,
) -> Canvas {
    const timer = draw_bevel_panel(
        canvas,
        make_rect(layout.hud_left, layout.hud_top, layout.hud_width - 4, 5),
        palette_panel_light(vga),
        palette_panel_dark(vga),
        palette_panel_fill(vga),
    );
    const timer_label = Canvas::text(timer, layout.hud_left + 2, layout.hud_top + 1, "TIME", palette_title(vga), palette_panel_fill(vga), true);
    const timer_value = Canvas::text(timer_label, layout.hud_left + 2, layout.hud_top + 3, "02:15", palette_title(vga), palette_panel_fill(vga), true);

    const level = draw_bevel_panel(
        timer_value,
        make_rect(layout.hud_left, layout.hud_top + 6, layout.hud_width - 4, 5),
        palette_panel_light(vga),
        palette_panel_dark(vga),
        palette_panel_fill(vga),
    );
    const level_label = Canvas::text(level, layout.hud_left + 2, layout.hud_top + 7, "LEVEL", palette_title(vga), palette_panel_fill(vga), true);
    const level_value = Canvas::text(level_label, layout.hud_left + 2, layout.hud_top + 9, "MEDIUM", palette_title(vga), palette_panel_fill(vga), true);

    const keypad = draw_keypad(level_value, layout.hud_left + 1, layout.hud_top + 12, vga);
    const tool_strip = draw_tools(keypad, layout.hud_left + 1, layout.hud_top + 20, vga);

    const debug_text = match debug_enabled {
        true => format!("DEBUG ON  FPS {:>3}", fps);
        false => String::from("DEBUG OFF");
    };
    const status_panel = Canvas::fill_rect(
        tool_strip,
        layout.hud_left,
        layout.hud_top + 24,
        layout.hud_width - 4,
        2,
        ' ',
        palette_hud_text(vga),
        palette_panel_fill(vga),
        false,
    );
    const status_text = Canvas::text(status_panel, layout.hud_left + 1, layout.hud_top + 24, debug_text, palette_debug_fg(vga), palette_debug_bg(vga), true);
    Canvas::text(status_text, layout.hud_left + 1, layout.hud_top + 25, status, palette_hud_text(vga), palette_panel_fill(vga), false)
}

fn draw_keypad(canvas: Canvas, x: i64, y: i64, vga: bool) -> Canvas {
    let next = canvas;
    for row in 0..3 {
        for col in 0..3 {
            const number = row * 3 + col + 1;
            const bx = x + col * 9;
            const by = y + row * 3;
            const button = draw_bevel_panel(
                next,
                make_rect(bx, by, 8, 3),
                palette_panel_light(vga),
                palette_panel_dark(vga),
                palette_panel_fill(vga),
            );
            const text = format!("{}", number);
            next = Canvas::text(button, bx + 3, by + 1, text, palette_title(vga), palette_panel_fill(vga), true);
        }
    }
    next
}

fn draw_tools(canvas: Canvas, x: i64, y: i64, vga: bool) -> Canvas {
    const erase = draw_bevel_panel(
        canvas,
        make_rect(x, y, 26, 3),
        231,
        palette_panel_dark(vga),
        160,
    );
    const erase_label = Canvas::text(erase, x + 9, y + 1, "ERASE", 231, 160, true);
    const hint = draw_bevel_panel(
        erase_label,
        make_rect(x, y + 4, 26, 3),
        231,
        palette_panel_dark(vga),
        34,
    );
    Canvas::text(hint, x + 10, y + 5, "HINT", 231, 34, true)
}

fn draw_footer_strip(canvas: Canvas, layout: SceneLayout, vga: bool) -> Canvas {
    const base = Canvas::fill_rect(canvas, 0, layout.footer_y - 3, 120, 6, ' ', palette_text(vga), palette_bg(vga), false);
    const plate = draw_bevel_panel(
        base,
        make_rect(4, layout.footer_y - 3, 112, 2),
        palette_panel_light(vga),
        palette_panel_dark(vga),
        palette_wood_mid(vga),
    );
    Canvas::text(plate, 6, layout.footer_y - 2, "BOARD GAME RUNTIME :: wood + tile + hud composition", palette_hud_text(vga), palette_wood_mid(vga), false)
}

fn blend_band(top: i64, bottom: i64, row: i64, total_rows: i64) -> i64 {
    if total_rows <= 1 {
        return top;
    }
    top + ((bottom - top) * row) / (total_rows - 1)
}

fn palette_hill_a(vga: bool) -> i64 {
    if vga {
        return 71;
    }
    70
}

fn palette_hill_b(vga: bool) -> i64 {
    if vga {
        return 77;
    }
    76
}

fn palette_hill_c(vga: bool) -> i64 {
    if vga {
        return 113;
    }
    112
}

fn palette_brick_a(vga: bool) -> i64 {
    if vga {
        return 137;
    }
    137
}

fn palette_brick_b(vga: bool) -> i64 {
    if vga {
        return 173;
    }
    173
}

fn palette_brick_c(vga: bool) -> i64 {
    if vga {
        return 94;
    }
    94
}
