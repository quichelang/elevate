# Ownership Architecture: Requirements-Based Tiered Lowering

## Core Principle

**Stop inferring intent. Infer only requirements.**

Instead of "what did the user mean?", the compiler asks four questions about each binding:

| Question | Bit | Example trigger |
|----------|-----|-----------------|
| **Aliased?** | More than one live handle exists | `let b = a` when `a` used later |
| **Mutated?** | Written through any handle | `x.push(1)`, `x[i] = v` |
| **Escapes?** | Stored, returned, captured, globalized | `return x`, `self.data = x` |
| **Shared across threads?** | Sent to spawn/channel/async | `spawn(fn(): x.push(1))` |

These four bits deterministically select a **tier**. No heuristics, no mind-reading.

---

## The Performance Ladder (4 Tiers)

Lowering is **monotonic**: start at Tier 0, upgrade only when forced. Once upgraded, a binding stays at that tier within its scope.

### Tier 0: Plain Ownership (zero-cost)

**When**: No aliasing, no escape, no threading.

| Usage | Generated Rust |
|-------|---------------|
| Read-only param | `fn f(x: &T)` |
| Mutated param (not consumed) | `fn f(x: &mut T)` |
| Consumed param (returned/moved) | `fn f(x: T)` |
| Local binding | `let x: T` / `let mut x: T` |
| Iteration | `for n in &x` (read) or `for n in x` (consume) |

This is where **most code lives**. Zero overhead, maximal Rust performance.

### Tier 1: Reborrow Discipline (still zero-cost, compiler works harder)

**When**: Aliasing detected but resolvable through borrowing discipline.

The compiler introduces temporaries, splits borrows, or shortens lifetimes to satisfy Rust's borrow checker:

```rust
// Elevate source:
//   let a = data[0]     ← borrows data
//   data.push(42)       ← mutates data (conflict!)

// Tier 1 rewrite: introduce temporary
let a = data[0].clone();  // or copy if Copy
data.push(42);             // no conflict
```

**Still zero-cost in terms of wrappers.** The compiler just restructures borrows.

### Tier 2: Interior Mutability (single-thread, runtime-checked)

**When**: Aliasing + mutation through different handles, unresolvable by Tier 1.

```rust
// Elevate source:
//   let a = data
//   let b = data     ← aliasing!
//   b.push(1)        ← mutation through alias!

// Tier 2 lowering:
let data = Rc::new(RefCell::new(vec![...]));
let a = Rc::clone(&data);
let b = Rc::clone(&data);
b.borrow_mut().push(1);   // runtime borrow check
```

| Wrapper | When |
|---------|------|
| `Cell<T>` | Copy types, simple read/write |
| `RefCell<T>` | Non-Copy, single-thread |
| `Rc<RefCell<T>>` | Aliased + non-Copy + single-thread |

### Tier 3: Thread-Safe (concurrent, runtime-checked)

**When**: Value crosses thread boundaries.

```rust
// Tier 3 lowering:
let data = Arc::new(Mutex::new(vec![...]));
// or Arc::new(RwLock::new(vec![...])) for read-heavy workloads
```

---

## Per-Parameter Requirement Summaries

Each function gets a **summary** computed once (not full body analysis):

```
fn push_item(nums: Vec<i64>, val: i64)
  nums: { reads: true, writes: true, consumes: false, escapes: false }
  val:  { reads: true, writes: false, consumes: false, escapes: false }
```

At call sites, the summary drives lowering:

| Summary | Call-site lowering |
|---------|-------------------|
| reads only | `f(&x)` |
| writes, no aliasing conflict | `f(&mut x)` |
| consumes (and source not needed later) | `f(x)` (move) |
| consumes (but source IS needed later) | `f(x.clone())` |
| writes + aliasing conflict | upgrade to Tier 2, `f(&x)` with `RefCell` inside |

---

## The Aliasing Question

**What happens with `a = v; b = v; b.push(1);`?**

This is the critical design decision. I propose:

### Rule: Assignment is **move** by default; aliasing is detected and upgraded

```python
let v = [1, 2, 3]
let a = v          # move: v is now invalid (Tier 0)
a.push(4)          # fine, a owns the data
# print(v)         # ← compile error: v was moved to a
```

```python
let v = [1, 2, 3]
let a = v          # v used later → aliasing detected!
let b = v          # v used later → more aliasing!
b.push(1)          # mutation through alias → Tier 2
print(a)           # a sees the mutation (shared via Rc<RefCell>)
```

**User mental model**: "If I use a value after giving it to someone else, it becomes shared. Shared + mutated = runtime-checked."

> [!IMPORTANT]
> The user never writes `Rc`, `RefCell`, `Arc`, or `Mutex`. The compiler upgrades transparently. They only observe: "if I share things, it might be slightly slower."

### `const` as an optimization hint

```python
const config = load_config()   # promise: never mutated
process(config)                # always &T, never upgraded
process(config)                # aliasing is fine — immutable sharing is free
```

`const` = "I promise this is immutable." The compiler can share it freely at Tier 0 (multiple `&T` borrows are always valid).

---

## What This Replaces

| Current system | Replaced by |
|---------------|-------------|
| `param_is_consumed_in_body()` | Requirement summary: `escapes` bit |
| `collect_mutated_paths_in_stmts()` | Requirement summary: `writes` bit |
| Auto-clone insertion | Tier assignment (Tier 0 moves, Tier 2 shares) |
| `known_function_mut_args` | Per-function requirement summaries |
| Ad-hoc `MutBorrow` detection in codegen | Tier-driven call-site lowering |

---

## Optional Hints

When the compiler's analysis isn't what the user wants:

```python
fn read(ref data: Vec[i64]):      # force Tier 0 &T
fn modify(mut data: Vec[i64]):    # force Tier 0 &mut T
fn consume(own data: Vec[i64]):   # force Tier 0 owned T
```

These bypass the tiering system entirely — the user asserts the requirement.

---

## Implementation Phases

### Phase 1: Requirement Summaries (immediate — fixes current bugs)

1. Replace `param_is_consumed_in_body` + `collect_mutated_paths_in_stmts` with a unified `compute_param_requirements(body) → HashMap<String, Requirements>` where `Requirements = { reads, writes, consumes, escapes }`
2. Use summaries in `lower_function`: `writes && !consumes && !escapes` → `&mut T`; `reads && !writes && !consumes` → `&T`; else → `T`
3. Auto-rewrite `for n in param` → `for n in &param` when param is `&T`/`&mut T`
4. Store summaries in `LoweringState` for call-site lookup

### Phase 2: Aliasing Detection (next — enables Tier 1)

1. Track binding liveness: does a variable have uses after a move/pass?
2. When aliasing detected + mutation-free: clone (Tier 1)
3. When aliasing detected + mutation-through-alias: flag for Tier 2

### Phase 3: Interior Mutability Lowering (later — Tier 2)

1. Emit `Rc<RefCell<T>>` for aliased+mutated bindings
2. Rewrite access: `x.push(1)` → `x.borrow_mut().push(1)`
3. Rewrite assignment: `let b = x` → `let b = Rc::clone(&x)`

### Phase 4: Thread Safety (future — Tier 3)

1. Detect spawn/channel/async patterns
2. Emit `Arc<Mutex<T>>` or `Arc<RwLock<T>>`

---

## Verification (Phase 1 focus)

| Test case | Expected tier | Expected signature |
|-----------|-------------|-------------------|
| `push_item(nums, val)` | 0 | `nums: &mut Vec<i64>, val: i64` |
| `sum_vec(nums)` | 0 | `nums: &Vec<i64>` (read-only, iter borrows) |
| `double_values(nums)` | 0 | `nums: &mut Vec<i64>` |
| `extend_with(dst, src)` | 0 | `dst: &mut Vec<i64>, src: &Vec<i64>` |
| `sorted(items) -> Vec` | 0 | `items: Vec<i64>` (consumed: returned) |
| `a = v; push(a); print(v)` | 2 | `v` upgraded to `Rc<RefCell<Vec<i64>>>` |
| `const c = [1,2]; f(c); g(c)` | 0 | `c: &Vec<i64>` (immutable, shared freely) |
