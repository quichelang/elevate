use crate::ir::lowered::{
    RustBinaryOp, RustConst, RustDestructurePattern, RustEnum, RustExpr, RustFunction, RustImpl,
    RustItem, RustModule, RustPattern, RustStatic, RustStmt, RustStruct, RustUnaryOp, RustUse,
};

pub fn emit_rust_module(module: &RustModule) -> String {
    let mut out = String::new();
    out.push_str("// Generated by elevate compiler.\n");
    out.push_str("// Do not edit generated output manually.\n\n");
    for item in &module.items {
        match item {
            RustItem::Use(def) => emit_use(def, &mut out),
            RustItem::Struct(def) => emit_struct(def, &mut out),
            RustItem::Enum(def) => emit_enum(def, &mut out),
            RustItem::Impl(def) => emit_impl(def, &mut out),
            RustItem::Function(def) => emit_function(def, &mut out),
            RustItem::Const(def) => emit_const(def, &mut out),
            RustItem::Static(def) => emit_static(def, &mut out),
        }
        out.push('\n');
    }
    out
}

fn emit_use(def: &RustUse, out: &mut String) {
    out.push_str("use ");
    out.push_str(&def.path.join("::"));
    out.push_str(";\n");
}

fn emit_struct(def: &RustStruct, out: &mut String) {
    out.push_str("#[derive(Debug, Clone)]\n");
    out.push_str(&format!("{}struct {} {{\n", vis(def.is_public), def.name));
    for field in &def.fields {
        out.push_str(&format!("    pub {}: {},\n", field.name, field.ty));
    }
    out.push_str("}\n");
}

fn emit_enum(def: &RustEnum, out: &mut String) {
    out.push_str("#[derive(Debug, Clone)]\n");
    out.push_str(&format!("{}enum {} {{\n", vis(def.is_public), def.name));
    for variant in &def.variants {
        match &variant.payload {
            Some(payload) => out.push_str(&format!("    {}({}),\n", variant.name, payload)),
            None => out.push_str(&format!("    {},\n", variant.name)),
        }
    }
    out.push_str("}\n");
}

fn emit_function(def: &RustFunction, out: &mut String) {
    let params = def
        .params
        .iter()
        .map(|p| format!("{}: {}", p.name, p.ty))
        .collect::<Vec<_>>()
        .join(", ");
    out.push_str(&format!("{}fn {}({})", vis(def.is_public), def.name, params));
    out.push_str(&format!(" -> {}", def.return_type));
    out.push_str(" {\n");
    for stmt in &def.body {
        emit_stmt(stmt, out);
    }
    out.push_str("}\n");
}

fn emit_impl(def: &RustImpl, out: &mut String) {
    out.push_str(&format!("impl {} {{\n", def.target));
    for method in &def.methods {
        let params = method
            .params
            .iter()
            .map(|p| format!("{}: {}", p.name, p.ty))
            .collect::<Vec<_>>()
            .join(", ");
        out.push_str(&format!(
            "    {}fn {}({}) -> {} {{\n",
            vis(method.is_public),
            method.name,
            params,
            method.return_type
        ));
        for stmt in &method.body {
            emit_stmt_with_indent(stmt, out, 2);
        }
        out.push_str("    }\n");
    }
    out.push_str("}\n");
}

fn emit_stmt(stmt: &RustStmt, out: &mut String) {
    match stmt {
        RustStmt::Const(def) => {
            out.push_str(&format!(
                "    let {}: {} = {};\n",
                def.name,
                def.ty,
                emit_expr(&def.value)
            ));
        }
        RustStmt::Return(Some(expr)) => {
            out.push_str(&format!("    return {};\n", emit_expr(expr)));
        }
        RustStmt::Return(None) => {
            out.push_str("    return;\n");
        }
        RustStmt::DestructureConst { pattern, value } => {
            out.push_str(&format!(
                "    let {} = {};\n",
                emit_destructure_pattern(pattern),
                emit_expr(value)
            ));
        }
        RustStmt::If {
            condition,
            then_body,
            else_body,
        } => {
            out.push_str(&format!("    if {} {{\n", emit_expr(condition)));
            for stmt in then_body {
                emit_stmt_with_indent(stmt, out, 2);
            }
            out.push_str("    }");
            if let Some(else_body) = else_body {
                out.push_str(" else {\n");
                for stmt in else_body {
                    emit_stmt_with_indent(stmt, out, 2);
                }
                out.push_str("    }");
            }
            out.push('\n');
        }
        RustStmt::While { condition, body } => {
            out.push_str(&format!("    while {} {{\n", emit_expr(condition)));
            for stmt in body {
                emit_stmt_with_indent(stmt, out, 2);
            }
            out.push_str("    }\n");
        }
        RustStmt::Expr(expr) => {
            out.push_str(&format!("    {};\n", emit_expr(expr)));
        }
    }
}

fn emit_const(def: &RustConst, out: &mut String) {
    out.push_str(vis(def.is_public));
    out.push_str("const ");
    out.push_str(&def.name);
    out.push_str(&format!(": {}", def.ty));
    out.push_str(" = ");
    out.push_str(&emit_expr(&def.value));
    out.push_str(";\n");
}

fn emit_static(def: &RustStatic, out: &mut String) {
    out.push_str(&format!(
        "{}static {}: {} = {};\n",
        vis(def.is_public),
        def.name,
        def.ty,
        emit_expr(&def.value)
    ));
}

fn emit_expr(expr: &RustExpr) -> String {
    match expr {
        RustExpr::Int(value) => value.to_string(),
        RustExpr::Bool(value) => value.to_string(),
        RustExpr::String(value) => format!("::std::string::String::from({value:?})"),
        RustExpr::Path(path) => path.join("::"),
        RustExpr::Call { callee, args } => {
            let args = args.iter().map(emit_expr).collect::<Vec<_>>().join(", ");
            format!("{}({args})", emit_expr(callee))
        }
        RustExpr::Field { base, field } => format!("{}.{}", emit_expr(base), field),
        RustExpr::Match { scrutinee, arms } => {
            let mut text = String::new();
            text.push_str("match ");
            text.push_str(&emit_expr(scrutinee));
            text.push_str(" { ");
            for arm in arms {
                text.push_str(&emit_pattern(&arm.pattern));
                text.push_str(" => ");
                text.push_str(&emit_expr(&arm.value));
                text.push_str(", ");
            }
            text.push('}');
            text
        }
        RustExpr::Unary { op, expr } => match op {
            RustUnaryOp::Not => format!("!{}", emit_expr(expr)),
        },
        RustExpr::Binary { op, left, right } => {
            let symbol = match op {
                RustBinaryOp::And => "&&",
                RustBinaryOp::Or => "||",
                RustBinaryOp::Eq => "==",
                RustBinaryOp::Ne => "!=",
                RustBinaryOp::Lt => "<",
                RustBinaryOp::Le => "<=",
                RustBinaryOp::Gt => ">",
                RustBinaryOp::Ge => ">=",
            };
            format!("({} {} {})", emit_expr(left), symbol, emit_expr(right))
        }
        RustExpr::Tuple(items) => {
            if items.is_empty() {
                "()".to_string()
            } else {
                let body = items.iter().map(emit_expr).collect::<Vec<_>>().join(", ");
                format!("({body})")
            }
        }
        RustExpr::Range {
            start,
            end,
            inclusive,
        } => {
            let start = start.as_ref().map(|v| emit_expr(v)).unwrap_or_default();
            let end = end.as_ref().map(|v| emit_expr(v)).unwrap_or_default();
            let op = if *inclusive { "..=" } else { ".." };
            format!("{start}{op}{end}")
        }
        RustExpr::Try(inner) => format!("{}?", emit_expr(inner)),
    }
}

fn emit_pattern(pattern: &RustPattern) -> String {
    match pattern {
        RustPattern::Wildcard => "_".to_string(),
        RustPattern::Variant { path, binding } => {
            if let Some(binding) = binding {
                format!("{}({binding})", path.join("::"))
            } else {
                path.join("::")
            }
        }
    }
}

fn emit_destructure_pattern(pattern: &RustDestructurePattern) -> String {
    match pattern {
        RustDestructurePattern::Name(name) => name.clone(),
        RustDestructurePattern::Ignore => "_".to_string(),
        RustDestructurePattern::Tuple(items) => {
            let inner = items
                .iter()
                .map(emit_destructure_pattern)
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
    }
}

fn emit_stmt_with_indent(stmt: &RustStmt, out: &mut String, indent: usize) {
    let pad = "    ".repeat(indent);
    match stmt {
        RustStmt::Const(def) => {
            out.push_str(&format!(
                "{pad}let {}: {} = {};\n",
                def.name,
                def.ty,
                emit_expr(&def.value)
            ));
        }
        RustStmt::Return(Some(expr)) => out.push_str(&format!("{pad}return {};\n", emit_expr(expr))),
        RustStmt::Return(None) => out.push_str(&format!("{pad}return;\n")),
        RustStmt::DestructureConst { pattern, value } => {
            out.push_str(&format!(
                "{pad}let {} = {};\n",
                emit_destructure_pattern(pattern),
                emit_expr(value)
            ));
        }
        RustStmt::If {
            condition,
            then_body,
            else_body,
        } => {
            out.push_str(&format!("{pad}if {} {{\n", emit_expr(condition)));
            for nested in then_body {
                emit_stmt_with_indent(nested, out, indent + 1);
            }
            out.push_str(&format!("{pad}}}"));
            if let Some(else_body) = else_body {
                out.push_str(" else {\n");
                for nested in else_body {
                    emit_stmt_with_indent(nested, out, indent + 1);
                }
                out.push_str(&format!("{pad}}}"));
            }
            out.push('\n');
        }
        RustStmt::While { condition, body } => {
            out.push_str(&format!("{pad}while {} {{\n", emit_expr(condition)));
            for nested in body {
                emit_stmt_with_indent(nested, out, indent + 1);
            }
            out.push_str(&format!("{pad}}}\n"));
        }
        RustStmt::Expr(expr) => out.push_str(&format!("{pad}{};\n", emit_expr(expr))),
    }
}

fn vis(is_public: bool) -> &'static str {
    if is_public {
        "pub "
    } else {
        ""
    }
}
