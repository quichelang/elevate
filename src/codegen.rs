use crate::ir::lowered::{
    RustAssignOp, RustAssignTarget, RustBinaryOp, RustConst, RustDestructurePattern, RustEnum,
    RustExpr, RustFunction, RustImpl, RustItem, RustModule, RustPattern, RustPatternField,
    RustStatic, RustStmt, RustStruct, RustStructLiteralField, RustUnaryOp, RustUse,
};

pub fn emit_rust_module(module: &RustModule) -> String {
    let mut out = String::new();
    out.push_str("// Generated by elevate compiler.\n");
    out.push_str("// Do not edit generated output manually.\n\n");
    for note in &module.ownership_notes {
        out.push_str("// ownership-note: ");
        out.push_str(note);
        out.push('\n');
    }
    if !module.ownership_notes.is_empty() {
        out.push('\n');
    }
    for item in &module.items {
        match item {
            RustItem::Use(def) => emit_use(def, &mut out),
            RustItem::Struct(def) => emit_struct(def, &mut out),
            RustItem::Enum(def) => emit_enum(def, &mut out),
            RustItem::Impl(def) => emit_impl(def, &mut out),
            RustItem::Function(def) => emit_function(def, &mut out),
            RustItem::Const(def) => emit_const(def, &mut out),
            RustItem::Static(def) => emit_static(def, &mut out),
        }
        out.push('\n');
    }
    out
}

fn emit_use(def: &RustUse, out: &mut String) {
    out.push_str("use ");
    out.push_str(&def.path.join("::"));
    out.push_str(";\n");
}

fn emit_struct(def: &RustStruct, out: &mut String) {
    out.push_str("#[derive(Debug, Clone)]\n");
    out.push_str(&format!("{}struct {} {{\n", vis(def.is_public), def.name));
    for field in &def.fields {
        out.push_str(&format!("    pub {}: {},\n", field.name, field.ty));
    }
    out.push_str("}\n");
}

fn emit_enum(def: &RustEnum, out: &mut String) {
    out.push_str("#[derive(Debug, Clone)]\n");
    out.push_str(&format!("{}enum {} {{\n", vis(def.is_public), def.name));
    for variant in &def.variants {
        match &variant.payload {
            Some(payload) => out.push_str(&format!("    {}({}),\n", variant.name, payload)),
            None => out.push_str(&format!("    {},\n", variant.name)),
        }
    }
    out.push_str("}\n");
}

fn emit_function(def: &RustFunction, out: &mut String) {
    let mutated = collect_mutated_paths_in_stmts(&def.body);
    let params = def
        .params
        .iter()
        .map(|p| {
            if mutated.contains(&p.name) {
                format!("mut {}: {}", p.name, p.ty)
            } else {
                format!("{}: {}", p.name, p.ty)
            }
        })
        .collect::<Vec<_>>()
        .join(", ");
    out.push_str(&format!(
        "{}fn {}({})",
        vis(def.is_public),
        def.name,
        params
    ));
    out.push_str(&format!(" -> {}", def.return_type));
    out.push_str(" {\n");
    for stmt in &def.body {
        emit_stmt(stmt, out);
    }
    out.push_str("}\n");
}

fn emit_impl(def: &RustImpl, out: &mut String) {
    out.push_str(&format!("impl {} {{\n", def.target));
    for method in &def.methods {
        let mutated = collect_mutated_paths_in_stmts(&method.body);
        let params = method
            .params
            .iter()
            .map(|p| {
                if mutated.contains(&p.name) {
                    format!("mut {}: {}", p.name, p.ty)
                } else {
                    format!("{}: {}", p.name, p.ty)
                }
            })
            .collect::<Vec<_>>()
            .join(", ");
        out.push_str(&format!(
            "    {}fn {}({}) -> {} {{\n",
            vis(method.is_public),
            method.name,
            params,
            method.return_type
        ));
        for stmt in &method.body {
            emit_stmt_with_indent(stmt, out, 2);
        }
        out.push_str("    }\n");
    }
    out.push_str("}\n");
}

fn emit_stmt(stmt: &RustStmt, out: &mut String) {
    match stmt {
        RustStmt::Const(def) => {
            let value = emit_expr(&def.value);
            if should_annotate_local_binding(&def.ty, &def.value) {
                out.push_str(&format!("    let {}: {} = {};\n", def.name, def.ty, value));
            } else {
                out.push_str(&format!("    let {} = {};\n", def.name, value));
            }
        }
        RustStmt::Return(Some(expr)) => {
            out.push_str(&format!("    return {};\n", emit_expr(expr)));
        }
        RustStmt::Return(None) => {
            out.push_str("    return;\n");
        }
        RustStmt::DestructureConst { pattern, value } => {
            out.push_str(&format!(
                "    let {} = {};\n",
                emit_destructure_pattern(pattern),
                emit_expr(value)
            ));
        }
        RustStmt::Assign { target, op, value } => {
            let op = match op {
                RustAssignOp::Assign => "=",
                RustAssignOp::AddAssign => "+=",
            };
            out.push_str(&format!(
                "    {} {} {};\n",
                emit_assign_target(target),
                op,
                emit_expr(value)
            ));
        }
        RustStmt::If {
            condition,
            then_body,
            else_body,
        } => {
            out.push_str(&format!("    if {} {{\n", emit_condition_expr(condition)));
            for stmt in then_body {
                emit_stmt_with_indent(stmt, out, 2);
            }
            out.push_str("    }");
            if let Some(else_body) = else_body {
                out.push_str(" else {\n");
                for stmt in else_body {
                    emit_stmt_with_indent(stmt, out, 2);
                }
                out.push_str("    }");
            }
            out.push('\n');
        }
        RustStmt::While { condition, body } => {
            out.push_str(&format!("    while {} {{\n", emit_condition_expr(condition)));
            for stmt in body {
                emit_stmt_with_indent(stmt, out, 2);
            }
            out.push_str("    }\n");
        }
        RustStmt::Loop { body } => {
            out.push_str("    loop {\n");
            for stmt in body {
                emit_stmt_with_indent(stmt, out, 2);
            }
            out.push_str("    }\n");
        }
        RustStmt::Break => out.push_str("    break;\n"),
        RustStmt::Continue => out.push_str("    continue;\n"),
        RustStmt::Expr(expr) => {
            out.push_str(&format!("    {};\n", emit_expr(expr)));
        }
    }
}

fn emit_const(def: &RustConst, out: &mut String) {
    out.push_str(vis(def.is_public));
    out.push_str("const ");
    out.push_str(&def.name);
    out.push_str(&format!(": {}", def.ty));
    out.push_str(" = ");
    out.push_str(&emit_expr(&def.value));
    out.push_str(";\n");
}

fn emit_static(def: &RustStatic, out: &mut String) {
    out.push_str(&format!(
        "{}static {}: {} = {};\n",
        vis(def.is_public),
        def.name,
        def.ty,
        emit_expr(&def.value)
    ));
}

fn emit_expr(expr: &RustExpr) -> String {
    match expr {
        RustExpr::Int(value) => value.to_string(),
        RustExpr::Bool(value) => value.to_string(),
        RustExpr::String(value) => format!("::std::string::String::from({value:?})"),
        RustExpr::Path(path) => path.join("::"),
        RustExpr::Borrow(inner) => {
            let inner_text = emit_expr(inner);
            if needs_parens_for_borrow(inner) {
                format!("&({inner_text})")
            } else {
                format!("&{inner_text}")
            }
        }
        RustExpr::Call { callee, args } => {
            let args = args.iter().map(emit_expr).collect::<Vec<_>>().join(", ");
            let callee_text = emit_expr(callee);
            let callee_text = if needs_parens_for_call(callee.as_ref()) {
                format!("({callee_text})")
            } else {
                callee_text
            };
            format!("{callee_text}({args})")
        }
        RustExpr::MacroCall { path, args } => {
            let args = if is_format_style_macro(path) {
                args.iter()
                    .enumerate()
                    .map(|(index, arg)| {
                        if index == 0 {
                            if let RustExpr::String(value) = arg {
                                return format!("{value:?}");
                            }
                        }
                        emit_expr(arg)
                    })
                    .collect::<Vec<_>>()
                    .join(", ")
            } else {
                args.iter().map(emit_expr).collect::<Vec<_>>().join(", ")
            };
            format!("{}!({args})", path.join("::"))
        }
        RustExpr::Field { base, field } => format!("{}.{}", emit_expr(base), field),
        RustExpr::Match { scrutinee, arms } => {
            let mut text = String::new();
            text.push_str("match ");
            text.push_str(&emit_expr(scrutinee));
            text.push_str(" { ");
            for arm in arms {
                text.push_str(&emit_pattern(&arm.pattern));
                if let Some(guard) = &arm.guard {
                    text.push_str(" if ");
                    text.push_str(&emit_expr(guard));
                }
                text.push_str(" => ");
                text.push_str(&emit_expr(&arm.value));
                text.push_str(", ");
            }
            text.push('}');
            text
        }
        RustExpr::Unary { op, expr } => match op {
            RustUnaryOp::Not => format!("!{}", emit_expr(expr)),
        },
        RustExpr::Binary { op, left, right } => {
            let symbol = match op {
                RustBinaryOp::And => "&&",
                RustBinaryOp::Or => "||",
                RustBinaryOp::Add => "+",
                RustBinaryOp::Eq => "==",
                RustBinaryOp::Ne => "!=",
                RustBinaryOp::Lt => "<",
                RustBinaryOp::Le => "<=",
                RustBinaryOp::Gt => ">",
                RustBinaryOp::Ge => ">=",
            };
            format!("({} {} {})", emit_expr(left), symbol, emit_expr(right))
        }
        RustExpr::Tuple(items) => {
            if items.is_empty() {
                "()".to_string()
            } else {
                let body = items.iter().map(emit_expr).collect::<Vec<_>>().join(", ");
                format!("({body})")
            }
        }
        RustExpr::StructLiteral { path, fields } => {
            let body = fields
                .iter()
                .map(emit_struct_literal_field)
                .collect::<Vec<_>>()
                .join(", ");
            format!("{} {{ {} }}", path.join("::"), body)
        }
        RustExpr::Closure {
            params,
            return_type,
            body,
        } => {
            let mutated = collect_mutated_paths_in_stmts(body);
            let params = params
                .iter()
                .map(|p| {
                    if mutated.contains(&p.name) {
                        format!("mut {}: {}", p.name, p.ty)
                    } else {
                        format!("{}: {}", p.name, p.ty)
                    }
                })
                .collect::<Vec<_>>()
                .join(", ");
            let mut text = format!("|{params}| -> {return_type} {{\n");
            for stmt in body {
                emit_stmt_with_indent(stmt, &mut text, 1);
            }
            text.push('}');
            text
        }
        RustExpr::Range {
            start,
            end,
            inclusive,
        } => {
            let start = start.as_ref().map(|v| emit_expr(v)).unwrap_or_default();
            let end = end.as_ref().map(|v| emit_expr(v)).unwrap_or_default();
            let op = if *inclusive { "..=" } else { ".." };
            format!("{start}{op}{end}")
        }
        RustExpr::Try(inner) => format!("{}?", emit_expr(inner)),
    }
}

fn is_format_style_macro(path: &[String]) -> bool {
    path.len() == 1
        && matches!(
            path[0].as_str(),
            "format" | "println" | "eprintln" | "panic"
        )
}

fn emit_struct_literal_field(field: &RustStructLiteralField) -> String {
    format!("{}: {}", field.name, emit_expr(&field.value))
}

fn emit_assign_target(target: &RustAssignTarget) -> String {
    match target {
        RustAssignTarget::Path(name) => name.clone(),
        RustAssignTarget::Field { base, field } => format!("{}.{}", emit_expr(base), field),
        RustAssignTarget::Tuple(items) => {
            let inner = items
                .iter()
                .map(emit_assign_target)
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
    }
}

fn emit_pattern(pattern: &RustPattern) -> String {
    match pattern {
        RustPattern::Wildcard => "_".to_string(),
        RustPattern::Binding(name) => name.clone(),
        RustPattern::Int(value) => value.to_string(),
        RustPattern::Bool(value) => value.to_string(),
        RustPattern::String(value) => format!("{value:?}"),
        RustPattern::Tuple(items) => {
            let inner = items
                .iter()
                .map(emit_pattern)
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
        RustPattern::Or(items) => items.iter().map(emit_pattern).collect::<Vec<_>>().join(" | "),
        RustPattern::BindingAt { name, pattern } => {
            format!("{name} @ {}", emit_pattern(pattern))
        }
        RustPattern::Struct { path, fields } => {
            let inner = fields
                .iter()
                .map(emit_pattern_field)
                .collect::<Vec<_>>()
                .join(", ");
            format!("{} {{ {} }}", path.join("::"), inner)
        }
        RustPattern::Range {
            start,
            end,
            inclusive,
        } => {
            let start = start.map(|v| v.to_string()).unwrap_or_default();
            let end = end.map(|v| v.to_string()).unwrap_or_default();
            let op = if *inclusive { "..=" } else { ".." };
            format!("{start}{op}{end}")
        }
        RustPattern::Variant { path, payload } => {
            if let Some(payload) = payload {
                if let RustPattern::Tuple(items) = payload.as_ref() {
                    let inner = items.iter().map(emit_pattern).collect::<Vec<_>>().join(", ");
                    format!("{}({inner})", path.join("::"))
                } else {
                    format!("{}({})", path.join("::"), emit_pattern(payload))
                }
            } else {
                path.join("::")
            }
        }
    }
}

fn emit_pattern_field(field: &RustPatternField) -> String {
    match &field.pattern {
        RustPattern::Binding(name) if name == &field.name => field.name.clone(),
        pattern => format!("{}: {}", field.name, emit_pattern(pattern)),
    }
}

fn emit_destructure_pattern(pattern: &RustDestructurePattern) -> String {
    match pattern {
        RustDestructurePattern::Name(name) => name.clone(),
        RustDestructurePattern::Ignore => "_".to_string(),
        RustDestructurePattern::Tuple(items) => {
            let inner = items
                .iter()
                .map(emit_destructure_pattern)
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
    }
}

fn emit_stmt_with_indent(stmt: &RustStmt, out: &mut String, indent: usize) {
    let pad = "    ".repeat(indent);
    match stmt {
        RustStmt::Const(def) => {
            let value = emit_expr(&def.value);
            if should_annotate_local_binding(&def.ty, &def.value) {
                out.push_str(&format!("{pad}let {}: {} = {};\n", def.name, def.ty, value));
            } else {
                out.push_str(&format!("{pad}let {} = {};\n", def.name, value));
            }
        }
        RustStmt::Return(Some(expr)) => {
            out.push_str(&format!("{pad}return {};\n", emit_expr(expr)))
        }
        RustStmt::Return(None) => out.push_str(&format!("{pad}return;\n")),
        RustStmt::DestructureConst { pattern, value } => {
            out.push_str(&format!(
                "{pad}let {} = {};\n",
                emit_destructure_pattern(pattern),
                emit_expr(value)
            ));
        }
        RustStmt::Assign { target, op, value } => {
            let op = match op {
                RustAssignOp::Assign => "=",
                RustAssignOp::AddAssign => "+=",
            };
            out.push_str(&format!(
                "{pad}{} {} {};\n",
                emit_assign_target(target),
                op,
                emit_expr(value)
            ));
        }
        RustStmt::If {
            condition,
            then_body,
            else_body,
        } => {
            out.push_str(&format!("{pad}if {} {{\n", emit_condition_expr(condition)));
            for nested in then_body {
                emit_stmt_with_indent(nested, out, indent + 1);
            }
            out.push_str(&format!("{pad}}}"));
            if let Some(else_body) = else_body {
                out.push_str(" else {\n");
                for nested in else_body {
                    emit_stmt_with_indent(nested, out, indent + 1);
                }
                out.push_str(&format!("{pad}}}"));
            }
            out.push('\n');
        }
        RustStmt::While { condition, body } => {
            out.push_str(&format!("{pad}while {} {{\n", emit_condition_expr(condition)));
            for nested in body {
                emit_stmt_with_indent(nested, out, indent + 1);
            }
            out.push_str(&format!("{pad}}}\n"));
        }
        RustStmt::Loop { body } => {
            out.push_str(&format!("{pad}loop {{\n"));
            for nested in body {
                emit_stmt_with_indent(nested, out, indent + 1);
            }
            out.push_str(&format!("{pad}}}\n"));
        }
        RustStmt::Break => out.push_str(&format!("{pad}break;\n")),
        RustStmt::Continue => out.push_str(&format!("{pad}continue;\n")),
        RustStmt::Expr(expr) => out.push_str(&format!("{pad}{};\n", emit_expr(expr))),
    }
}

fn vis(is_public: bool) -> &'static str {
    if is_public { "pub " } else { "" }
}

fn should_annotate_local_binding(ty: &str, value: &RustExpr) -> bool {
    if ty == "_" {
        return false;
    }
    !matches!(value, RustExpr::Closure { .. })
}

fn needs_parens_for_call(expr: &RustExpr) -> bool {
    matches!(
        expr,
        RustExpr::Closure { .. }
            | RustExpr::Match { .. }
            | RustExpr::Unary { .. }
            | RustExpr::Binary { .. }
            | RustExpr::Range { .. }
    )
}

fn needs_parens_for_borrow(expr: &RustExpr) -> bool {
    matches!(
        expr,
        RustExpr::Closure { .. }
            | RustExpr::Match { .. }
            | RustExpr::Unary { .. }
            | RustExpr::Binary { .. }
            | RustExpr::Range { .. }
    )
}

fn emit_condition_expr(expr: &RustExpr) -> String {
    let rendered = emit_expr(expr);
    if condition_clause_count(expr) == 1 {
        strip_outer_parens(&rendered).to_string()
    } else {
        rendered
    }
}

fn condition_clause_count(expr: &RustExpr) -> usize {
    match expr {
        RustExpr::Binary { op, left, right } if matches!(op, RustBinaryOp::And | RustBinaryOp::Or) => {
            condition_clause_count(left) + condition_clause_count(right)
        }
        _ => 1,
    }
}

fn strip_outer_parens(text: &str) -> &str {
    let bytes = text.as_bytes();
    if bytes.len() >= 2 && bytes[0] == b'(' && bytes[bytes.len() - 1] == b')' {
        let mut depth = 0usize;
        for (index, ch) in bytes.iter().enumerate() {
            match *ch {
                b'(' => depth += 1,
                b')' => {
                    if depth == 0 {
                        return text;
                    }
                    depth -= 1;
                    if depth == 0 && index + 1 != bytes.len() {
                        return text;
                    }
                }
                _ => {}
            }
        }
        if depth == 0 {
            return &text[1..text.len() - 1];
        }
    }
    text
}

fn collect_mutated_paths_in_stmts(stmts: &[RustStmt]) -> std::collections::HashSet<String> {
    let mut out = std::collections::HashSet::new();
    for stmt in stmts {
        collect_mutated_paths_in_stmt(stmt, &mut out);
    }
    out
}

fn collect_mutated_paths_in_stmt(
    stmt: &RustStmt,
    out: &mut std::collections::HashSet<String>,
) {
    match stmt {
        RustStmt::Assign { target, .. } => {
            collect_mutated_paths_in_target(target, out);
        }
        RustStmt::If {
            then_body,
            else_body,
            ..
        } => {
            for stmt in then_body {
                collect_mutated_paths_in_stmt(stmt, out);
            }
            if let Some(else_body) = else_body {
                for stmt in else_body {
                    collect_mutated_paths_in_stmt(stmt, out);
                }
            }
        }
        RustStmt::While { body, .. } => {
            for stmt in body {
                collect_mutated_paths_in_stmt(stmt, out);
            }
        }
        RustStmt::Loop { body } => {
            for stmt in body {
                collect_mutated_paths_in_stmt(stmt, out);
            }
        }
        RustStmt::Const(_)
        | RustStmt::DestructureConst { .. }
        | RustStmt::Break
        | RustStmt::Continue
        | RustStmt::Return(_)
        | RustStmt::Expr(_) => {}
    }
}

fn collect_mutated_paths_in_target(
    target: &RustAssignTarget,
    out: &mut std::collections::HashSet<String>,
) {
    match target {
        RustAssignTarget::Path(name) => {
            out.insert(name.clone());
        }
        RustAssignTarget::Field { base, .. } => {
            if let Some(name) = root_path_name(base) {
                out.insert(name.to_string());
            }
        }
        RustAssignTarget::Tuple(items) => {
            for item in items {
                collect_mutated_paths_in_target(item, out);
            }
        }
    }
}

fn root_path_name(expr: &RustExpr) -> Option<&str> {
    match expr {
        RustExpr::Path(path) if path.len() == 1 => Some(path[0].as_str()),
        RustExpr::Field { base, .. } => root_path_name(base),
        _ => None,
    }
}
