use crate::ir::lowered::{
    RustConst, RustEnum, RustExpr, RustFunction, RustItem, RustModule, RustStatic, RustStmt,
    RustStruct, RustUse,
};

pub fn emit_rust_module(module: &RustModule) -> String {
    let mut out = String::new();
    out.push_str("// Generated by elevate compiler.\n");
    out.push_str("// Do not edit generated output manually.\n\n");
    for item in &module.items {
        match item {
            RustItem::Use(def) => emit_use(def, &mut out),
            RustItem::Struct(def) => emit_struct(def, &mut out),
            RustItem::Enum(def) => emit_enum(def, &mut out),
            RustItem::Function(def) => emit_function(def, &mut out),
            RustItem::Const(def) => emit_const(def, &mut out),
            RustItem::Static(def) => emit_static(def, &mut out),
        }
        out.push('\n');
    }
    out
}

fn emit_use(def: &RustUse, out: &mut String) {
    out.push_str("use ");
    out.push_str(&def.path.join("::"));
    out.push_str(";\n");
}

fn emit_struct(def: &RustStruct, out: &mut String) {
    out.push_str("#[derive(Debug, Clone)]\n");
    out.push_str(&format!("pub struct {} {{\n", def.name));
    for field in &def.fields {
        out.push_str(&format!("    pub {}: {},\n", field.name, field.ty));
    }
    out.push_str("}\n");
}

fn emit_enum(def: &RustEnum, out: &mut String) {
    out.push_str("#[derive(Debug, Clone)]\n");
    out.push_str(&format!("pub enum {} {{\n", def.name));
    for variant in &def.variants {
        match &variant.payload {
            Some(payload) => out.push_str(&format!("    {}({}),\n", variant.name, payload)),
            None => out.push_str(&format!("    {},\n", variant.name)),
        }
    }
    out.push_str("}\n");
}

fn emit_function(def: &RustFunction, out: &mut String) {
    let params = def
        .params
        .iter()
        .map(|p| format!("{}: {}", p.name, p.ty))
        .collect::<Vec<_>>()
        .join(", ");
    out.push_str(&format!("pub fn {}({})", def.name, params));
    out.push_str(&format!(" -> {}", def.return_type));
    out.push_str(" {\n");
    for stmt in &def.body {
        emit_stmt(stmt, out);
    }
    out.push_str("}\n");
}

fn emit_stmt(stmt: &RustStmt, out: &mut String) {
    match stmt {
        RustStmt::Const(def) => {
            out.push_str(&format!(
                "    let {}: {} = {};\n",
                def.name,
                def.ty,
                emit_expr(&def.value)
            ));
        }
        RustStmt::Return(Some(expr)) => {
            out.push_str(&format!("    return {};\n", emit_expr(expr)));
        }
        RustStmt::Return(None) => {
            out.push_str("    return;\n");
        }
        RustStmt::Expr(expr) => {
            out.push_str(&format!("    {};\n", emit_expr(expr)));
        }
    }
}

fn emit_const(def: &RustConst, out: &mut String) {
    out.push_str("pub const ");
    out.push_str(&def.name);
    out.push_str(&format!(": {}", def.ty));
    out.push_str(" = ");
    out.push_str(&emit_expr(&def.value));
    out.push_str(";\n");
}

fn emit_static(def: &RustStatic, out: &mut String) {
    out.push_str(&format!(
        "pub static {}: {} = {};\n",
        def.name,
        def.ty,
        emit_expr(&def.value)
    ));
}

fn emit_expr(expr: &RustExpr) -> String {
    match expr {
        RustExpr::Int(value) => value.to_string(),
        RustExpr::Bool(value) => value.to_string(),
        RustExpr::String(value) => format!("{value:?}"),
        RustExpr::Path(path) => path.join("::"),
        RustExpr::Call { callee, args } => {
            let args = args.iter().map(emit_expr).collect::<Vec<_>>().join(", ");
            format!("{}({args})", emit_expr(callee))
        }
        RustExpr::Field { base, field } => format!("{}.{}", emit_expr(base), field),
        RustExpr::Try(inner) => format!("{}?", emit_expr(inner)),
    }
}
