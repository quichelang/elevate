use crate::ir::lowered::{
    RustAssignOp, RustAssignTarget, RustBinaryOp, RustConst, RustDestructurePattern, RustEnum,
    RustExpr, RustFunction, RustImpl, RustItem, RustModule, RustPattern, RustPatternField,
    RustStatic, RustStmt, RustStruct, RustStructLiteralField, RustTrait, RustUnaryOp, RustUse,
    RustUseTree, RustVariantFields,
};

pub fn emit_rust_module(module: &RustModule) -> String {
    let mut out = String::new();
    out.push_str("#![allow(unused_parens)]\n");
    out.push_str("#![allow(dropping_copy_types)]\n");
    out.push_str("#![allow(dropping_references)]\n\n");
    out.push_str("// Generated by elevate compiler.\n");
    out.push_str("// Do not edit generated output manually.\n\n");
    for note in &module.ownership_notes {
        out.push_str("// ownership-note: ");
        out.push_str(note);
        out.push('\n');
    }
    if !module.ownership_notes.is_empty() {
        out.push('\n');
    }
    for item in &module.items {
        match item {
            RustItem::Use(def) => emit_use(def, &mut out),
            RustItem::Raw(code) => emit_raw_item(code, &mut out),
            RustItem::Struct(def) => emit_struct(def, &mut out),
            RustItem::Enum(def) => emit_enum(def, &mut out),
            RustItem::Trait(def) => emit_trait(def, &mut out),
            RustItem::Impl(def) => emit_impl(def, &mut out),
            RustItem::Function(def) => emit_function(def, &mut out),
            RustItem::Const(def) => emit_const(def, &mut out),
            RustItem::Static(def) => emit_static(def, &mut out),
        }
        out.push('\n');
    }
    out
}

fn emit_use(def: &RustUse, out: &mut String) {
    out.push_str("use ");
    out.push_str(&emit_use_tree(&def.tree));
    out.push_str(";\n");
}

fn emit_use_tree(tree: &RustUseTree) -> String {
    match tree {
        RustUseTree::Name(name) => name.clone(),
        RustUseTree::Glob => "*".to_string(),
        RustUseTree::Path { segment, next } => format!("{segment}::{}", emit_use_tree(next)),
        RustUseTree::Group(items) => {
            let rendered = items
                .iter()
                .map(emit_use_tree)
                .collect::<Vec<_>>()
                .join(", ");
            format!("{{{rendered}}}")
        }
    }
}

fn emit_raw_item(code: &str, out: &mut String) {
    out.push_str(code.trim());
    out.push('\n');
}

fn emit_struct(def: &RustStruct, out: &mut String) {
    let generics = emit_type_params(&def.type_params);
    out.push_str("#[derive(Debug, Clone)]\n");
    out.push_str(&format!(
        "{}struct {}{} {{\n",
        vis(def.is_public),
        def.name,
        generics
    ));
    for field in &def.fields {
        out.push_str(&format!("    pub {}: {},\n", field.name, field.ty));
    }
    out.push_str("}\n");
}

fn emit_enum(def: &RustEnum, out: &mut String) {
    let generics = emit_type_params(&def.type_params);
    out.push_str("#[derive(Debug, Clone)]\n");
    out.push_str(&format!(
        "{}enum {}{} {{\n",
        vis(def.is_public),
        def.name,
        generics
    ));
    for variant in &def.variants {
        match &variant.fields {
            RustVariantFields::Unit => {
                out.push_str(&format!("    {},\n", variant.name));
            }
            RustVariantFields::Tuple(items) => {
                out.push_str(&format!("    {}({}),\n", variant.name, items.join(", ")));
            }
            RustVariantFields::Named(fields) => {
                out.push_str(&format!("    {} {{ ", variant.name));
                let rendered = fields
                    .iter()
                    .map(|field| format!("{}: {}", field.name, field.ty))
                    .collect::<Vec<_>>()
                    .join(", ");
                out.push_str(&rendered);
                out.push_str(" },\n");
            }
        }
    }
    out.push_str("}\n");
}

fn emit_trait(def: &RustTrait, out: &mut String) {
    let supers = if def.supertraits.is_empty() {
        String::new()
    } else {
        format!(": {}", def.supertraits.join(" + "))
    };
    out.push_str(&format!(
        "{}trait {}{} {{\n",
        vis(def.is_public),
        def.name,
        supers
    ));
    for method in &def.methods {
        let params = method
            .params
            .iter()
            .map(|p| format!("{}: {}", p.name, p.ty))
            .collect::<Vec<_>>()
            .join(", ");
        let generics = if method.type_params.is_empty() {
            String::new()
        } else {
            let params = method
                .type_params
                .iter()
                .map(emit_type_param)
                .collect::<Vec<_>>()
                .join(", ");
            format!("<{params}>")
        };
        out.push_str(&format!(
            "    fn {}{}({}) -> {};\n",
            method.name, generics, params, method.return_type
        ));
    }
    out.push_str("}\n");
}

fn emit_function(def: &RustFunction, out: &mut String) {
    let mutated = collect_mutated_paths_in_stmts(&def.body);
    let params = def
        .params
        .iter()
        .map(|p| {
            if mutated.contains(&p.name) && !p.ty.trim_start().starts_with("&mut") {
                format!("mut {}: {}", p.name, p.ty)
            } else {
                format!("{}: {}", p.name, p.ty)
            }
        })
        .collect::<Vec<_>>()
        .join(", ");
    let generics = emit_type_params(&def.type_params);
    out.push_str(&format!(
        "{}fn {}{}({})",
        vis(def.is_public),
        def.name,
        generics,
        params
    ));
    out.push_str(&format!(" -> {}", def.return_type));
    out.push_str(" {\n");
    for stmt in &def.body {
        emit_stmt_with_indent(stmt, out, 1, &mutated);
    }
    out.push_str("}\n");
}

fn emit_impl(def: &RustImpl, out: &mut String) {
    let in_trait_impl = def.trait_target.is_some();
    let generics = emit_type_params(&def.type_params);
    let target = emit_named_type(&def.target, &def.target_args);
    if let Some(trait_target) = &def.trait_target {
        out.push_str(&format!(
            "impl{} {} for {} {{\n",
            generics, trait_target, target
        ));
    } else {
        out.push_str(&format!("impl{} {} {{\n", generics, target));
    }
    for method in &def.methods {
        let mutated = collect_mutated_paths_in_stmts(&method.body);
        let params = method
            .params
            .iter()
            .map(|p| {
                if mutated.contains(&p.name) && !p.ty.trim_start().starts_with("&mut") {
                    format!("mut {}: {}", p.name, p.ty)
                } else {
                    format!("{}: {}", p.name, p.ty)
                }
            })
            .collect::<Vec<_>>()
            .join(", ");
        let generics = emit_type_params(&method.type_params);
        if in_trait_impl {
            out.push_str(&format!(
                "    fn {}{}({}) -> {} {{\n",
                method.name, generics, params, method.return_type
            ));
        } else {
            out.push_str(&format!(
                "    {}fn {}{}({}) -> {} {{\n",
                vis(method.is_public),
                method.name,
                generics,
                params,
                method.return_type
            ));
        }
        for stmt in &method.body {
            emit_stmt_with_indent(stmt, out, 2, &mutated);
        }
        out.push_str("    }\n");
    }
    out.push_str("}\n");
}

fn emit_const(def: &RustConst, out: &mut String) {
    out.push_str(vis(def.is_public));
    out.push_str("const ");
    out.push_str(&def.name);
    out.push_str(&format!(": {}", def.ty));
    out.push_str(" = ");
    out.push_str(&emit_expr(&def.value));
    out.push_str(";\n");
}

fn emit_static(def: &RustStatic, out: &mut String) {
    out.push_str(&format!(
        "{}static {}: {} = {};\n",
        vis(def.is_public),
        def.name,
        def.ty,
        emit_expr(&def.value)
    ));
}

fn emit_expr(expr: &RustExpr) -> String {
    match expr {
        RustExpr::Int(value) => value.to_string(),
        RustExpr::Float(value) => value.clone(),
        RustExpr::Bool(value) => value.to_string(),
        RustExpr::Char(value) => emit_char_literal(*value),
        RustExpr::String(value) => format!("::std::string::String::from({value:?})"),
        RustExpr::Path(path) => path.join("::"),
        RustExpr::Borrow(inner) => {
            let inner_text = emit_expr(inner);
            if needs_parens_for_borrow(inner) {
                format!("&({inner_text})")
            } else {
                format!("&{inner_text}")
            }
        }
        RustExpr::MutBorrow(inner) => {
            let inner_text = emit_expr(inner);
            if needs_parens_for_borrow(inner) {
                format!("&mut ({inner_text})")
            } else {
                format!("&mut {inner_text}")
            }
        }
        RustExpr::Cast { expr, ty } => format!("({} as {})", emit_expr(expr), ty),
        RustExpr::Call { callee, args, .. } => {
            let args = args.iter().map(emit_expr).collect::<Vec<_>>().join(", ");
            let callee_text = emit_expr(callee);
            let callee_text = if needs_parens_for_call(callee.as_ref()) {
                format!("({callee_text})")
            } else {
                callee_text
            };
            format!("{callee_text}({args})")
        }
        RustExpr::MacroCall { path, args } => {
            let args = if is_format_style_macro(path) {
                args.iter()
                    .enumerate()
                    .map(|(index, arg)| {
                        if index == 0 {
                            if let RustExpr::String(value) = arg {
                                return format!("{value:?}");
                            }
                        }
                        emit_expr(arg)
                    })
                    .collect::<Vec<_>>()
                    .join(", ")
            } else {
                args.iter().map(emit_expr).collect::<Vec<_>>().join(", ")
            };
            format!("{}!({args})", path.join("::"))
        }
        RustExpr::Field { base, field } => format!("{}.{}", emit_expr(base), field),
        RustExpr::Index { base, index } => {
            let base_text = emit_expr(base);
            let index_text = emit_expr(index);
            format!("{base_text}[{index_text}]")
        }
        RustExpr::Match { scrutinee, arms } => {
            let mut text = String::new();
            text.push_str("match ");
            text.push_str(&emit_expr(scrutinee));
            text.push_str(" { ");
            for arm in arms {
                text.push_str(&emit_pattern(&arm.pattern));
                if let Some(guard) = &arm.guard {
                    text.push_str(" if ");
                    text.push_str(&emit_expr(guard));
                }
                text.push_str(" => ");
                text.push_str(&emit_expr(&arm.value));
                text.push_str(", ");
            }
            text.push('}');
            text
        }
        RustExpr::Unary { op, expr } => match op {
            RustUnaryOp::Not => format!("!{}", emit_expr(expr)),
            RustUnaryOp::Neg => format!("-{}", emit_expr(expr)),
        },
        RustExpr::Binary { op, left, right } => {
            let symbol = match op {
                RustBinaryOp::And => "&&",
                RustBinaryOp::Or => "||",
                RustBinaryOp::Add => "+",
                RustBinaryOp::Sub => "-",
                RustBinaryOp::Mul => "*",
                RustBinaryOp::Div => "/",
                RustBinaryOp::Rem => "%",
                RustBinaryOp::Eq => "==",
                RustBinaryOp::Ne => "!=",
                RustBinaryOp::Lt => "<",
                RustBinaryOp::Le => "<=",
                RustBinaryOp::Gt => ">",
                RustBinaryOp::Ge => ">=",
            };
            format!("({} {} {})", emit_expr(left), symbol, emit_expr(right))
        }
        RustExpr::Array(items) => {
            let body = items.iter().map(emit_expr).collect::<Vec<_>>().join(", ");
            format!("vec![{body}]")
        }
        RustExpr::Tuple(items) => {
            if items.is_empty() {
                "()".to_string()
            } else {
                let body = items.iter().map(emit_expr).collect::<Vec<_>>().join(", ");
                format!("({body})")
            }
        }
        RustExpr::StructLiteral { path, fields } => {
            let body = fields
                .iter()
                .map(emit_struct_literal_field)
                .collect::<Vec<_>>()
                .join(", ");
            format!("{} {{ {} }}", path.join("::"), body)
        }
        RustExpr::Block { body, tail } => {
            let mut text = String::from("{\n");
            let mutated_body = collect_mutated_paths_in_stmts(body);
            for stmt in body {
                emit_stmt_with_indent(stmt, &mut text, 1, &mutated_body);
            }
            if let Some(tail) = tail {
                text.push_str("    ");
                text.push_str(&emit_expr(tail));
                text.push('\n');
            }
            text.push('}');
            text
        }
        RustExpr::Closure {
            params,
            return_type,
            body,
        } => {
            let mutated = collect_mutated_paths_in_stmts(body);
            let params = params
                .iter()
                .map(|p| {
                    if mutated.contains(&p.name) {
                        format!("mut {}: {}", p.name, p.ty)
                    } else {
                        format!("{}: {}", p.name, p.ty)
                    }
                })
                .collect::<Vec<_>>()
                .join(", ");
            let mut text = format!("|{params}| -> {return_type} {{\n");
            let mutated_body = collect_mutated_paths_in_stmts(body);
            for stmt in body {
                emit_stmt_with_indent(stmt, &mut text, 1, &mutated_body);
            }
            text.push('}');
            text
        }
        RustExpr::Range {
            start,
            end,
            inclusive,
        } => {
            let start = start.as_ref().map(|v| emit_expr(v)).unwrap_or_default();
            let end = end.as_ref().map(|v| emit_expr(v)).unwrap_or_default();
            let op = if *inclusive { "..=" } else { ".." };
            format!("{start}{op}{end}")
        }
        RustExpr::Try(inner) => format!("{}?", emit_expr(inner)),
    }
}

fn is_format_style_macro(path: &[String]) -> bool {
    path.len() == 1
        && matches!(
            path[0].as_str(),
            "format" | "println" | "eprintln" | "panic"
        )
}

fn emit_struct_literal_field(field: &RustStructLiteralField) -> String {
    format!("{}: {}", field.name, emit_expr(&field.value))
}

fn emit_assign_target(target: &RustAssignTarget) -> String {
    match target {
        RustAssignTarget::Path(name) => name.clone(),
        RustAssignTarget::Field { base, field } => format!("{}.{}", emit_expr(base), field),
        RustAssignTarget::Index { base, index } => {
            format!("{}[{}]", emit_expr(base), emit_expr(index))
        }
        RustAssignTarget::Tuple(items) => {
            let inner = items
                .iter()
                .map(emit_assign_target)
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
    }
}

fn emit_pattern(pattern: &RustPattern) -> String {
    match pattern {
        RustPattern::Wildcard => "_".to_string(),
        RustPattern::Binding(name) => name.clone(),
        RustPattern::Int(value) => value.to_string(),
        RustPattern::Bool(value) => value.to_string(),
        RustPattern::Char(value) => emit_char_literal(*value),
        RustPattern::String(value) => format!("{value:?}"),
        RustPattern::Tuple(items) => {
            let inner = items
                .iter()
                .map(emit_pattern)
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
        RustPattern::Slice {
            prefix,
            rest,
            suffix,
        } => {
            let mut items = Vec::new();
            items.extend(prefix.iter().map(emit_pattern));
            if let Some(name) = rest {
                items.push(format!("{name} @ .."));
            } else if !suffix.is_empty() {
                items.push("..".to_string());
            }
            items.extend(suffix.iter().map(emit_pattern));
            format!("[{}]", items.join(", "))
        }
        RustPattern::Or(items) => items
            .iter()
            .map(emit_pattern)
            .collect::<Vec<_>>()
            .join(" | "),
        RustPattern::BindingAt { name, pattern } => {
            format!("{name} @ {}", emit_pattern(pattern))
        }
        RustPattern::Struct {
            path,
            fields,
            has_rest,
        } => {
            let inner = fields
                .iter()
                .map(emit_pattern_field)
                .collect::<Vec<_>>()
                .join(", ");
            if *has_rest {
                if inner.is_empty() {
                    format!("{} {{ .. }}", path.join("::"))
                } else {
                    format!("{} {{ {}, .. }}", path.join("::"), inner)
                }
            } else {
                format!("{} {{ {} }}", path.join("::"), inner)
            }
        }
        RustPattern::Range {
            start,
            end,
            inclusive,
        } => {
            let start = start.map(|v| v.to_string()).unwrap_or_default();
            let end = end.map(|v| v.to_string()).unwrap_or_default();
            let op = if *inclusive { "..=" } else { ".." };
            format!("{start}{op}{end}")
        }
        RustPattern::Variant { path, payload } => {
            if let Some(payload) = payload {
                if let RustPattern::Tuple(items) = payload.as_ref() {
                    let inner = items
                        .iter()
                        .map(emit_pattern)
                        .collect::<Vec<_>>()
                        .join(", ");
                    format!("{}({inner})", path.join("::"))
                } else {
                    format!("{}({})", path.join("::"), emit_pattern(payload))
                }
            } else {
                path.join("::")
            }
        }
    }
}

fn emit_pattern_field(field: &RustPatternField) -> String {
    match &field.pattern {
        RustPattern::Binding(name) if name == &field.name => field.name.clone(),
        pattern => format!("{}: {}", field.name, emit_pattern(pattern)),
    }
}

fn emit_type_param(param: &crate::ir::lowered::RustTypeParam) -> String {
    if param.bounds.is_empty() {
        param.name.clone()
    } else {
        format!("{}: {}", param.name, param.bounds.join(" + "))
    }
}

fn emit_type_params(params: &[crate::ir::lowered::RustTypeParam]) -> String {
    if params.is_empty() {
        String::new()
    } else {
        format!(
            "<{}>",
            params
                .iter()
                .map(emit_type_param)
                .collect::<Vec<_>>()
                .join(", ")
        )
    }
}

fn emit_named_type(name: &str, args: &[String]) -> String {
    if args.is_empty() {
        name.to_string()
    } else {
        format!("{name}<{}>", args.join(", "))
    }
}

fn emit_destructure_pattern(
    pattern: &RustDestructurePattern,
    mutated: &std::collections::HashSet<String>,
    allow_mut: bool,
) -> String {
    match pattern {
        RustDestructurePattern::Name(name) => {
            if allow_mut && mutated.contains(name) {
                format!("mut {name}")
            } else {
                name.clone()
            }
        }
        RustDestructurePattern::Ignore => "_".to_string(),
        RustDestructurePattern::Tuple(items) => {
            let inner = items
                .iter()
                .map(|item| emit_destructure_pattern(item, mutated, allow_mut))
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
        RustDestructurePattern::Slice {
            prefix,
            rest,
            suffix,
        } => {
            let mut items = Vec::new();
            items.extend(
                prefix
                    .iter()
                    .map(|item| emit_destructure_pattern(item, mutated, allow_mut)),
            );
            if let Some(name) = rest {
                if allow_mut && mutated.contains(name) {
                    items.push(format!("mut {name} @ .."));
                } else {
                    items.push(format!("{name} @ .."));
                }
            } else if !suffix.is_empty() {
                items.push("..".to_string());
            }
            items.extend(
                suffix
                    .iter()
                    .map(|item| emit_destructure_pattern(item, mutated, allow_mut)),
            );
            format!("[{}]", items.join(", "))
        }
    }
}

fn emit_stmt_with_indent(
    stmt: &RustStmt,
    out: &mut String,
    indent: usize,
    mutated: &std::collections::HashSet<String>,
) {
    let pad = "    ".repeat(indent);
    match stmt {
        RustStmt::Const(def) => {
            let value = emit_expr(&def.value);
            let mut_kw = if !def.is_const && mutated.contains(&def.name) {
                "mut "
            } else {
                ""
            };
            if should_annotate_local_binding(&def.ty, &def.value) {
                out.push_str(&format!(
                    "{pad}let {mut_kw}{}: {} = {};\n",
                    def.name, def.ty, value
                ));
            } else {
                out.push_str(&format!("{pad}let {mut_kw}{} = {};\n", def.name, value));
            }
        }
        RustStmt::Return(Some(expr)) => {
            out.push_str(&format!("{pad}return {};\n", emit_expr(expr)))
        }
        RustStmt::Return(None) => out.push_str(&format!("{pad}return;\n")),
        RustStmt::DestructureConst {
            pattern,
            value,
            is_const,
        } => {
            let binding = emit_destructure_pattern(pattern, mutated, !*is_const);
            let value = emit_expr(value);
            if matches!(pattern, RustDestructurePattern::Slice { .. }) {
                out.push_str(&format!(
                    "{pad}let {binding} = {value}.as_slice() else {{ panic!(\"slice destructure mismatch\") }};\n"
                ));
                emit_slice_element_rebinds(pattern, out, indent, *is_const);
            } else {
                out.push_str(&format!("{pad}let {binding} = {value};\n"));
            }
        }
        RustStmt::Assign { target, op, value } => {
            let op = match op {
                RustAssignOp::Assign => "=",
                RustAssignOp::AddAssign => "+=",
            };
            out.push_str(&format!(
                "{pad}{} {} {};\n",
                emit_assign_target(target),
                op,
                emit_expr(value)
            ));
        }
        RustStmt::If {
            condition,
            then_body,
            else_body,
        } => {
            out.push_str(&format!("{pad}if {} {{\n", emit_condition_expr(condition)));
            for nested in then_body {
                emit_stmt_with_indent(nested, out, indent + 1, mutated);
            }
            out.push_str(&format!("{pad}}}"));
            if let Some(else_body) = else_body {
                out.push_str(" else {\n");
                for nested in else_body {
                    emit_stmt_with_indent(nested, out, indent + 1, mutated);
                }
                out.push_str(&format!("{pad}}}"));
            }
            out.push('\n');
        }
        RustStmt::While { condition, body } => {
            out.push_str(&format!(
                "{pad}while {} {{\n",
                emit_condition_expr(condition)
            ));
            for nested in body {
                emit_stmt_with_indent(nested, out, indent + 1, mutated);
            }
            out.push_str(&format!("{pad}}}\n"));
        }
        RustStmt::For {
            binding,
            iter,
            body,
        } => {
            if matches!(binding, RustDestructurePattern::Slice { .. }) {
                out.push_str(&format!("{pad}for __item in {} {{\n", emit_expr(iter)));
                out.push_str(&format!(
                    "{pad}    let {} = __item.as_slice() else {{ panic!(\"slice destructure mismatch\") }};\n",
                    emit_destructure_pattern(binding, mutated, true)
                ));
                emit_slice_element_rebinds(binding, out, indent + 1, false);
                for nested in body {
                    emit_stmt_with_indent(nested, out, indent + 1, mutated);
                }
                out.push_str(&format!("{pad}}}\n"));
            } else {
                out.push_str(&format!(
                    "{pad}for {} in {} {{\n",
                    emit_destructure_pattern(binding, mutated, true),
                    emit_expr(iter)
                ));
                for nested in body {
                    emit_stmt_with_indent(nested, out, indent + 1, mutated);
                }
                out.push_str(&format!("{pad}}}\n"));
            }
        }
        RustStmt::Loop { body } => {
            out.push_str(&format!("{pad}loop {{\n"));
            for nested in body {
                emit_stmt_with_indent(nested, out, indent + 1, mutated);
            }
            out.push_str(&format!("{pad}}}\n"));
        }
        RustStmt::Break => out.push_str(&format!("{pad}break;\n")),
        RustStmt::Continue => out.push_str(&format!("{pad}continue;\n")),
        RustStmt::Raw(code) => {
            out.push_str(&pad);
            out.push_str(code.trim());
            out.push('\n');
        }
        RustStmt::Expr(expr) => out.push_str(&format!("{pad}{};\n", emit_expr(expr))),
    }
}

fn vis(is_public: bool) -> &'static str {
    if is_public { "pub " } else { "" }
}

fn should_annotate_local_binding(ty: &str, value: &RustExpr) -> bool {
    if ty == "_" {
        return false;
    }
    !matches!(value, RustExpr::Closure { .. })
}

fn needs_parens_for_call(expr: &RustExpr) -> bool {
    matches!(
        expr,
        RustExpr::Closure { .. }
            | RustExpr::Block { .. }
            | RustExpr::Match { .. }
            | RustExpr::Unary { .. }
            | RustExpr::Binary { .. }
            | RustExpr::Cast { .. }
            | RustExpr::Range { .. }
    )
}

fn needs_parens_for_borrow(expr: &RustExpr) -> bool {
    matches!(
        expr,
        RustExpr::Closure { .. }
            | RustExpr::Block { .. }
            | RustExpr::Match { .. }
            | RustExpr::Unary { .. }
            | RustExpr::Binary { .. }
            | RustExpr::Cast { .. }
            | RustExpr::Range { .. }
    )
}

fn emit_condition_expr(expr: &RustExpr) -> String {
    let rendered = emit_expr(expr);
    if condition_clause_count(expr) == 1 {
        strip_outer_parens(&rendered).to_string()
    } else {
        rendered
    }
}

fn condition_clause_count(expr: &RustExpr) -> usize {
    match expr {
        RustExpr::Binary { op, left, right }
            if matches!(op, RustBinaryOp::And | RustBinaryOp::Or) =>
        {
            condition_clause_count(left) + condition_clause_count(right)
        }
        _ => 1,
    }
}

fn strip_outer_parens(text: &str) -> &str {
    let bytes = text.as_bytes();
    if bytes.len() >= 2 && bytes[0] == b'(' && bytes[bytes.len() - 1] == b')' {
        let mut depth = 0usize;
        for (index, ch) in bytes.iter().enumerate() {
            match *ch {
                b'(' => depth += 1,
                b')' => {
                    if depth == 0 {
                        return text;
                    }
                    depth -= 1;
                    if depth == 0 && index + 1 != bytes.len() {
                        return text;
                    }
                }
                _ => {}
            }
        }
        if depth == 0 {
            return &text[1..text.len() - 1];
        }
    }
    text
}

pub(crate) fn collect_mutated_paths_in_stmts(
    stmts: &[RustStmt],
) -> std::collections::HashSet<String> {
    let mut out = std::collections::HashSet::new();
    for stmt in stmts {
        collect_mutated_paths_in_stmt(stmt, &mut out);
    }
    out
}

fn collect_mutated_paths_in_stmt(stmt: &RustStmt, out: &mut std::collections::HashSet<String>) {
    match stmt {
        RustStmt::Assign { target, value, .. } => {
            collect_mutated_paths_in_target(target, out);
            collect_mutated_paths_in_expr(value, out);
        }
        RustStmt::If {
            condition,
            then_body,
            else_body,
            ..
        } => {
            collect_mutated_paths_in_expr(condition, out);
            for stmt in then_body {
                collect_mutated_paths_in_stmt(stmt, out);
            }
            if let Some(else_body) = else_body {
                for stmt in else_body {
                    collect_mutated_paths_in_stmt(stmt, out);
                }
            }
        }
        RustStmt::While { condition, body } => {
            collect_mutated_paths_in_expr(condition, out);
            for stmt in body {
                collect_mutated_paths_in_stmt(stmt, out);
            }
        }
        RustStmt::For { iter, body, .. } => {
            collect_mutated_paths_in_expr(iter, out);
            for stmt in body {
                collect_mutated_paths_in_stmt(stmt, out);
            }
        }
        RustStmt::Loop { body } => {
            for stmt in body {
                collect_mutated_paths_in_stmt(stmt, out);
            }
        }
        RustStmt::Const(def) => collect_mutated_paths_in_expr(&def.value, out),
        RustStmt::DestructureConst { value, .. } => collect_mutated_paths_in_expr(value, out),
        RustStmt::Return(Some(expr)) => collect_mutated_paths_in_expr(expr, out),
        RustStmt::Return(None) | RustStmt::Break | RustStmt::Continue | RustStmt::Raw(_) => {}
        RustStmt::Expr(expr) => collect_mutated_paths_in_expr(expr, out),
    }
}

fn collect_mutated_paths_in_target(
    target: &RustAssignTarget,
    out: &mut std::collections::HashSet<String>,
) {
    match target {
        RustAssignTarget::Path(name) => {
            out.insert(name.clone());
        }
        RustAssignTarget::Field { base, .. } => {
            if let Some(name) = root_path_name(base) {
                out.insert(name.to_string());
            }
        }
        RustAssignTarget::Index { base, .. } => {
            if let Some(name) = root_path_name(base) {
                out.insert(name.to_string());
            }
        }
        RustAssignTarget::Tuple(items) => {
            for item in items {
                collect_mutated_paths_in_target(item, out);
            }
        }
    }
}

fn collect_mutated_paths_in_expr(expr: &RustExpr, out: &mut std::collections::HashSet<String>) {
    match expr {
        RustExpr::Call {
            callee,
            args,
            mutates_receiver,
        } => {
            if *mutates_receiver {
                if let RustExpr::Field { base, .. } = callee.as_ref() {
                    if let Some(name) = root_path_name(base) {
                        out.insert(name.to_string());
                    }
                }
            }
            collect_mutated_paths_in_expr(callee, out);
            for arg in args {
                collect_mutated_paths_in_expr(arg, out);
            }
        }
        RustExpr::MacroCall { args, .. } => {
            for arg in args {
                collect_mutated_paths_in_expr(arg, out);
            }
        }
        RustExpr::Field { base, .. } => collect_mutated_paths_in_expr(base, out),
        RustExpr::Index { base, index } => {
            collect_mutated_paths_in_expr(base, out);
            collect_mutated_paths_in_expr(index, out);
        }
        RustExpr::Match { scrutinee, arms } => {
            collect_mutated_paths_in_expr(scrutinee, out);
            for arm in arms {
                if let Some(guard) = &arm.guard {
                    collect_mutated_paths_in_expr(guard, out);
                }
                collect_mutated_paths_in_expr(&arm.value, out);
            }
        }
        RustExpr::Unary { expr, .. } => collect_mutated_paths_in_expr(expr, out),
        RustExpr::Binary { left, right, .. } => {
            collect_mutated_paths_in_expr(left, out);
            collect_mutated_paths_in_expr(right, out);
        }
        RustExpr::Array(items) | RustExpr::Tuple(items) => {
            for item in items {
                collect_mutated_paths_in_expr(item, out);
            }
        }
        RustExpr::StructLiteral { fields, .. } => {
            for field in fields {
                collect_mutated_paths_in_expr(&field.value, out);
            }
        }
        RustExpr::Block { body, tail } => {
            for stmt in body {
                collect_mutated_paths_in_stmt(stmt, out);
            }
            if let Some(tail) = tail {
                collect_mutated_paths_in_expr(tail, out);
            }
        }
        RustExpr::Closure { body, .. } => {
            for stmt in body {
                collect_mutated_paths_in_stmt(stmt, out);
            }
        }
        RustExpr::Range { start, end, .. } => {
            if let Some(start) = start {
                collect_mutated_paths_in_expr(start, out);
            }
            if let Some(end) = end {
                collect_mutated_paths_in_expr(end, out);
            }
        }
        RustExpr::Try(inner)
        | RustExpr::Borrow(inner)
        | RustExpr::MutBorrow(inner)
        | RustExpr::Cast { expr: inner, .. } => collect_mutated_paths_in_expr(inner, out),
        RustExpr::Int(_)
        | RustExpr::Float(_)
        | RustExpr::Bool(_)
        | RustExpr::Char(_)
        | RustExpr::String(_)
        | RustExpr::Path(_) => {}
    }
}

fn emit_char_literal(value: char) -> String {
    match value {
        '\\' => "'\\\\'".to_string(),
        '\'' => "'\\''".to_string(),
        '\n' => "'\\n'".to_string(),
        '\r' => "'\\r'".to_string(),
        '\t' => "'\\t'".to_string(),
        '\0' => "'\\0'".to_string(),
        other => format!("'{other}'"),
    }
}

fn emit_slice_element_rebinds(
    pattern: &RustDestructurePattern,
    out: &mut String,
    indent: usize,
    is_const: bool,
) {
    let mut names = Vec::new();
    let rest_name = slice_rest_binding_name(pattern);
    collect_slice_element_binding_names(pattern, rest_name, &mut names);
    let pad = "    ".repeat(indent);
    for name in names {
        if is_const {
            out.push_str(&format!("{pad}let {name} = (*{name}).clone();\n"));
        } else {
            out.push_str(&format!("{pad}let mut {name} = (*{name}).clone();\n"));
        }
    }
    if let Some(rest) = rest_name {
        if is_const {
            out.push_str(&format!("{pad}let {rest} = {rest}.to_vec();\n"));
        } else {
            out.push_str(&format!("{pad}let mut {rest} = {rest}.to_vec();\n"));
        }
    }
}

fn slice_rest_binding_name(pattern: &RustDestructurePattern) -> Option<&str> {
    if let RustDestructurePattern::Slice { rest, .. } = pattern
        && let Some(name) = rest.as_deref()
    {
        return Some(name);
    }
    None
}

fn collect_slice_element_binding_names<'a>(
    pattern: &'a RustDestructurePattern,
    rest_name: Option<&'a str>,
    out: &mut Vec<&'a str>,
) {
    match pattern {
        RustDestructurePattern::Name(name) => {
            if Some(name.as_str()) != rest_name {
                out.push(name.as_str());
            }
        }
        RustDestructurePattern::Ignore => {}
        RustDestructurePattern::Tuple(items) => {
            for item in items {
                collect_slice_element_binding_names(item, rest_name, out);
            }
        }
        RustDestructurePattern::Slice {
            prefix,
            rest,
            suffix,
        } => {
            for item in prefix {
                collect_slice_element_binding_names(item, rest_name, out);
            }
            if let Some(rest_binding) = rest {
                if Some(rest_binding.as_str()) != rest_name {
                    out.push(rest_binding.as_str());
                }
            }
            for item in suffix {
                collect_slice_element_binding_names(item, rest_name, out);
            }
        }
    }
}

fn root_path_name(expr: &RustExpr) -> Option<&str> {
    match expr {
        RustExpr::Path(path) if path.len() == 1 => Some(path[0].as_str()),
        RustExpr::Field { base, .. } => root_path_name(base),
        RustExpr::Index { base, .. } => root_path_name(base),
        RustExpr::Borrow(inner) => root_path_name(inner),
        RustExpr::Cast { expr, .. } => root_path_name(expr),
        _ => None,
    }
}
