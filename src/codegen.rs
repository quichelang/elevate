use crate::ir::lowered::{
    RustAssignOp, RustAssignTarget, RustBinaryOp, RustConst, RustDestructurePattern, RustEnum,
    RustExpr, RustFunction, RustImpl, RustItem, RustModule, RustPattern, RustPatternField,
    RustStatic, RustStmt, RustStruct, RustStructLiteralField, RustUnaryOp, RustUse,
};

pub fn emit_rust_module(module: &RustModule) -> String {
    let mut out = String::new();
    out.push_str("// Generated by elevate compiler.\n");
    out.push_str("// Do not edit generated output manually.\n\n");
    for note in &module.ownership_notes {
        out.push_str("// ownership-note: ");
        out.push_str(note);
        out.push('\n');
    }
    if !module.ownership_notes.is_empty() {
        out.push('\n');
    }
    for item in &module.items {
        match item {
            RustItem::Use(def) => emit_use(def, &mut out),
            RustItem::Raw(code) => emit_raw_item(code, &mut out),
            RustItem::Struct(def) => emit_struct(def, &mut out),
            RustItem::Enum(def) => emit_enum(def, &mut out),
            RustItem::Impl(def) => emit_impl(def, &mut out),
            RustItem::Function(def) => emit_function(def, &mut out),
            RustItem::Const(def) => emit_const(def, &mut out),
            RustItem::Static(def) => emit_static(def, &mut out),
        }
        out.push('\n');
    }
    out
}

fn emit_use(def: &RustUse, out: &mut String) {
    out.push_str("use ");
    out.push_str(&def.path.join("::"));
    out.push_str(";\n");
}

fn emit_raw_item(code: &str, out: &mut String) {
    out.push_str(code.trim());
    out.push('\n');
}

fn emit_struct(def: &RustStruct, out: &mut String) {
    out.push_str("#[derive(Debug, Clone)]\n");
    out.push_str(&format!("{}struct {} {{\n", vis(def.is_public), def.name));
    for field in &def.fields {
        out.push_str(&format!("    pub {}: {},\n", field.name, field.ty));
    }
    out.push_str("}\n");
}

fn emit_enum(def: &RustEnum, out: &mut String) {
    out.push_str("#[derive(Debug, Clone)]\n");
    out.push_str(&format!("{}enum {} {{\n", vis(def.is_public), def.name));
    for variant in &def.variants {
        if variant.payload.is_empty() {
            out.push_str(&format!("    {},\n", variant.name));
        } else {
            out.push_str(&format!(
                "    {}({}),\n",
                variant.name,
                variant.payload.join(", ")
            ));
        }
    }
    out.push_str("}\n");
}

fn emit_function(def: &RustFunction, out: &mut String) {
    let mutated = collect_mutated_paths_in_stmts(&def.body);
    let params = def
        .params
        .iter()
        .map(|p| {
            if mutated.contains(&p.name) {
                format!("mut {}: {}", p.name, p.ty)
            } else {
                format!("{}: {}", p.name, p.ty)
            }
        })
        .collect::<Vec<_>>()
        .join(", ");
    let generics = if def.type_params.is_empty() {
        String::new()
    } else {
        let params = def
            .type_params
            .iter()
            .map(emit_type_param)
            .collect::<Vec<_>>()
            .join(", ");
        format!("<{params}>")
    };
    out.push_str(&format!(
        "{}fn {}{}({})",
        vis(def.is_public),
        def.name,
        generics,
        params
    ));
    out.push_str(&format!(" -> {}", def.return_type));
    out.push_str(" {\n");
    for stmt in &def.body {
        emit_stmt(stmt, out);
    }
    out.push_str("}\n");
}

fn emit_impl(def: &RustImpl, out: &mut String) {
    out.push_str(&format!("impl {} {{\n", def.target));
    for method in &def.methods {
        let mutated = collect_mutated_paths_in_stmts(&method.body);
        let params = method
            .params
            .iter()
            .map(|p| {
                if mutated.contains(&p.name) {
                    format!("mut {}: {}", p.name, p.ty)
                } else {
                    format!("{}: {}", p.name, p.ty)
                }
            })
            .collect::<Vec<_>>()
            .join(", ");
        let generics = if method.type_params.is_empty() {
            String::new()
        } else {
            let params = method
                .type_params
                .iter()
                .map(emit_type_param)
                .collect::<Vec<_>>()
                .join(", ");
            format!("<{params}>")
        };
        out.push_str(&format!(
            "    {}fn {}{}({}) -> {} {{\n",
            vis(method.is_public),
            method.name,
            generics,
            params,
            method.return_type
        ));
        for stmt in &method.body {
            emit_stmt_with_indent(stmt, out, 2);
        }
        out.push_str("    }\n");
    }
    out.push_str("}\n");
}

fn emit_stmt(stmt: &RustStmt, out: &mut String) {
    match stmt {
        RustStmt::Const(def) => {
            let value = emit_expr(&def.value);
            if should_annotate_local_binding(&def.ty, &def.value) {
                out.push_str(&format!("    let {}: {} = {};\n", def.name, def.ty, value));
            } else {
                out.push_str(&format!("    let {} = {};\n", def.name, value));
            }
        }
        RustStmt::Return(Some(expr)) => {
            out.push_str(&format!("    return {};\n", emit_expr(expr)));
        }
        RustStmt::Return(None) => {
            out.push_str("    return;\n");
        }
        RustStmt::DestructureConst { pattern, value } => {
            let binding = emit_destructure_pattern(pattern);
            let value = emit_expr(value);
            if matches!(pattern, RustDestructurePattern::Slice { .. }) {
                out.push_str(&format!(
                    "    let {binding} = {value}.as_slice() else {{ panic!(\"slice destructure mismatch\") }};\n"
                ));
                emit_slice_element_rebinds(pattern, out, 1);
            } else {
                out.push_str(&format!("    let {binding} = {value};\n"));
            }
        }
        RustStmt::Assign { target, op, value } => {
            let op = match op {
                RustAssignOp::Assign => "=",
                RustAssignOp::AddAssign => "+=",
            };
            out.push_str(&format!(
                "    {} {} {};\n",
                emit_assign_target(target),
                op,
                emit_expr(value)
            ));
        }
        RustStmt::If {
            condition,
            then_body,
            else_body,
        } => {
            out.push_str(&format!("    if {} {{\n", emit_condition_expr(condition)));
            for stmt in then_body {
                emit_stmt_with_indent(stmt, out, 2);
            }
            out.push_str("    }");
            if let Some(else_body) = else_body {
                out.push_str(" else {\n");
                for stmt in else_body {
                    emit_stmt_with_indent(stmt, out, 2);
                }
                out.push_str("    }");
            }
            out.push('\n');
        }
        RustStmt::While { condition, body } => {
            out.push_str(&format!("    while {} {{\n", emit_condition_expr(condition)));
            for stmt in body {
                emit_stmt_with_indent(stmt, out, 2);
            }
            out.push_str("    }\n");
        }
        RustStmt::For {
            binding,
            iter,
            body,
        } => {
            if matches!(binding, RustDestructurePattern::Slice { .. }) {
                out.push_str(&format!("    for __item in {} {{\n", emit_expr(iter)));
                out.push_str(&format!(
                    "        let {} = __item.as_slice() else {{ panic!(\"slice destructure mismatch\") }};\n",
                    emit_destructure_pattern(binding)
                ));
                emit_slice_element_rebinds(binding, out, 2);
                for stmt in body {
                    emit_stmt_with_indent(stmt, out, 2);
                }
                out.push_str("    }\n");
            } else {
                out.push_str(&format!(
                    "    for {} in {} {{\n",
                    emit_destructure_pattern(binding),
                    emit_expr(iter)
                ));
                for stmt in body {
                    emit_stmt_with_indent(stmt, out, 2);
                }
                out.push_str("    }\n");
            }
        }
        RustStmt::Loop { body } => {
            out.push_str("    loop {\n");
            for stmt in body {
                emit_stmt_with_indent(stmt, out, 2);
            }
            out.push_str("    }\n");
        }
        RustStmt::Break => out.push_str("    break;\n"),
        RustStmt::Continue => out.push_str("    continue;\n"),
        RustStmt::Raw(code) => {
            out.push_str("    ");
            out.push_str(code.trim());
            out.push('\n');
        }
        RustStmt::Expr(expr) => {
            out.push_str(&format!("    {};\n", emit_expr(expr)));
        }
    }
}

fn emit_const(def: &RustConst, out: &mut String) {
    out.push_str(vis(def.is_public));
    out.push_str("const ");
    out.push_str(&def.name);
    out.push_str(&format!(": {}", def.ty));
    out.push_str(" = ");
    out.push_str(&emit_expr(&def.value));
    out.push_str(";\n");
}

fn emit_static(def: &RustStatic, out: &mut String) {
    out.push_str(&format!(
        "{}static {}: {} = {};\n",
        vis(def.is_public),
        def.name,
        def.ty,
        emit_expr(&def.value)
    ));
}

fn emit_expr(expr: &RustExpr) -> String {
    match expr {
        RustExpr::Int(value) => value.to_string(),
        RustExpr::Bool(value) => value.to_string(),
        RustExpr::Char(value) => emit_char_literal(*value),
        RustExpr::String(value) => format!("::std::string::String::from({value:?})"),
        RustExpr::Path(path) => path.join("::"),
        RustExpr::Borrow(inner) => {
            let inner_text = emit_expr(inner);
            if needs_parens_for_borrow(inner) {
                format!("&({inner_text})")
            } else {
                format!("&{inner_text}")
            }
        }
        RustExpr::Cast { expr, ty } => format!("({} as {})", emit_expr(expr), ty),
        RustExpr::Call { callee, args } => {
            let args = args.iter().map(emit_expr).collect::<Vec<_>>().join(", ");
            let callee_text = emit_expr(callee);
            let callee_text = if needs_parens_for_call(callee.as_ref()) {
                format!("({callee_text})")
            } else {
                callee_text
            };
            format!("{callee_text}({args})")
        }
        RustExpr::MacroCall { path, args } => {
            let args = if is_format_style_macro(path) {
                args.iter()
                    .enumerate()
                    .map(|(index, arg)| {
                        if index == 0 {
                            if let RustExpr::String(value) = arg {
                                return format!("{value:?}");
                            }
                        }
                        emit_expr(arg)
                    })
                    .collect::<Vec<_>>()
                    .join(", ")
            } else {
                args.iter().map(emit_expr).collect::<Vec<_>>().join(", ")
            };
            format!("{}!({args})", path.join("::"))
        }
        RustExpr::Field { base, field } => format!("{}.{}", emit_expr(base), field),
        RustExpr::Index { base, index } => {
            let base_text = emit_expr(base);
            let index_text = emit_expr(index);
            if matches!(index.as_ref(), RustExpr::Range { .. }) {
                format!("{base_text}[{index_text}]")
            } else {
                format!("{base_text}[({index_text}) as usize]")
            }
        }
        RustExpr::Match { scrutinee, arms } => {
            let mut text = String::new();
            text.push_str("match ");
            text.push_str(&emit_expr(scrutinee));
            text.push_str(" { ");
            for arm in arms {
                text.push_str(&emit_pattern(&arm.pattern));
                if let Some(guard) = &arm.guard {
                    text.push_str(" if ");
                    text.push_str(&emit_expr(guard));
                }
                text.push_str(" => ");
                text.push_str(&emit_expr(&arm.value));
                text.push_str(", ");
            }
            text.push('}');
            text
        }
        RustExpr::Unary { op, expr } => match op {
            RustUnaryOp::Not => format!("!{}", emit_expr(expr)),
            RustUnaryOp::Neg => format!("-{}", emit_expr(expr)),
        },
        RustExpr::Binary { op, left, right } => {
            let symbol = match op {
                RustBinaryOp::And => "&&",
                RustBinaryOp::Or => "||",
                RustBinaryOp::Add => "+",
                RustBinaryOp::Sub => "-",
                RustBinaryOp::Mul => "*",
                RustBinaryOp::Div => "/",
                RustBinaryOp::Rem => "%",
                RustBinaryOp::Eq => "==",
                RustBinaryOp::Ne => "!=",
                RustBinaryOp::Lt => "<",
                RustBinaryOp::Le => "<=",
                RustBinaryOp::Gt => ">",
                RustBinaryOp::Ge => ">=",
            };
            format!("({} {} {})", emit_expr(left), symbol, emit_expr(right))
        }
        RustExpr::Array(items) => {
            let body = items.iter().map(emit_expr).collect::<Vec<_>>().join(", ");
            format!("vec![{body}]")
        }
        RustExpr::Tuple(items) => {
            if items.is_empty() {
                "()".to_string()
            } else {
                let body = items.iter().map(emit_expr).collect::<Vec<_>>().join(", ");
                format!("({body})")
            }
        }
        RustExpr::StructLiteral { path, fields } => {
            let body = fields
                .iter()
                .map(emit_struct_literal_field)
                .collect::<Vec<_>>()
                .join(", ");
            format!("{} {{ {} }}", path.join("::"), body)
        }
        RustExpr::Closure {
            params,
            return_type,
            body,
        } => {
            let mutated = collect_mutated_paths_in_stmts(body);
            let params = params
                .iter()
                .map(|p| {
                    if mutated.contains(&p.name) {
                        format!("mut {}: {}", p.name, p.ty)
                    } else {
                        format!("{}: {}", p.name, p.ty)
                    }
                })
                .collect::<Vec<_>>()
                .join(", ");
            let mut text = format!("|{params}| -> {return_type} {{\n");
            for stmt in body {
                emit_stmt_with_indent(stmt, &mut text, 1);
            }
            text.push('}');
            text
        }
        RustExpr::Range {
            start,
            end,
            inclusive,
        } => {
            let start = start.as_ref().map(|v| emit_expr(v)).unwrap_or_default();
            let end = end.as_ref().map(|v| emit_expr(v)).unwrap_or_default();
            let op = if *inclusive { "..=" } else { ".." };
            format!("{start}{op}{end}")
        }
        RustExpr::Try(inner) => format!("{}?", emit_expr(inner)),
    }
}

fn is_format_style_macro(path: &[String]) -> bool {
    path.len() == 1
        && matches!(
            path[0].as_str(),
            "format" | "println" | "eprintln" | "panic"
        )
}

fn emit_struct_literal_field(field: &RustStructLiteralField) -> String {
    format!("{}: {}", field.name, emit_expr(&field.value))
}

fn emit_assign_target(target: &RustAssignTarget) -> String {
    match target {
        RustAssignTarget::Path(name) => name.clone(),
        RustAssignTarget::Field { base, field } => format!("{}.{}", emit_expr(base), field),
        RustAssignTarget::Index { base, index } => {
            format!("{}[({}) as usize]", emit_expr(base), emit_expr(index))
        }
        RustAssignTarget::Tuple(items) => {
            let inner = items
                .iter()
                .map(emit_assign_target)
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
    }
}

fn emit_pattern(pattern: &RustPattern) -> String {
    match pattern {
        RustPattern::Wildcard => "_".to_string(),
        RustPattern::Binding(name) => name.clone(),
        RustPattern::Int(value) => value.to_string(),
        RustPattern::Bool(value) => value.to_string(),
        RustPattern::Char(value) => emit_char_literal(*value),
        RustPattern::String(value) => format!("{value:?}"),
        RustPattern::Tuple(items) => {
            let inner = items
                .iter()
                .map(emit_pattern)
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
        RustPattern::Slice {
            prefix,
            rest,
            suffix,
        } => {
            let mut items = Vec::new();
            items.extend(prefix.iter().map(emit_pattern));
            if let Some(name) = rest {
                items.push(format!("{name} @ .."));
            } else if !suffix.is_empty() {
                items.push("..".to_string());
            }
            items.extend(suffix.iter().map(emit_pattern));
            format!("[{}]", items.join(", "))
        }
        RustPattern::Or(items) => items.iter().map(emit_pattern).collect::<Vec<_>>().join(" | "),
        RustPattern::BindingAt { name, pattern } => {
            format!("{name} @ {}", emit_pattern(pattern))
        }
        RustPattern::Struct {
            path,
            fields,
            has_rest,
        } => {
            let inner = fields
                .iter()
                .map(emit_pattern_field)
                .collect::<Vec<_>>()
                .join(", ");
            if *has_rest {
                if inner.is_empty() {
                    format!("{} {{ .. }}", path.join("::"))
                } else {
                    format!("{} {{ {}, .. }}", path.join("::"), inner)
                }
            } else {
                format!("{} {{ {} }}", path.join("::"), inner)
            }
        }
        RustPattern::Range {
            start,
            end,
            inclusive,
        } => {
            let start = start.map(|v| v.to_string()).unwrap_or_default();
            let end = end.map(|v| v.to_string()).unwrap_or_default();
            let op = if *inclusive { "..=" } else { ".." };
            format!("{start}{op}{end}")
        }
        RustPattern::Variant { path, payload } => {
            if let Some(payload) = payload {
                if let RustPattern::Tuple(items) = payload.as_ref() {
                    let inner = items.iter().map(emit_pattern).collect::<Vec<_>>().join(", ");
                    format!("{}({inner})", path.join("::"))
                } else {
                    format!("{}({})", path.join("::"), emit_pattern(payload))
                }
            } else {
                path.join("::")
            }
        }
    }
}

fn emit_pattern_field(field: &RustPatternField) -> String {
    match &field.pattern {
        RustPattern::Binding(name) if name == &field.name => field.name.clone(),
        pattern => format!("{}: {}", field.name, emit_pattern(pattern)),
    }
}

fn emit_type_param(param: &crate::ir::lowered::RustTypeParam) -> String {
    if param.bounds.is_empty() {
        param.name.clone()
    } else {
        format!("{}: {}", param.name, param.bounds.join(" + "))
    }
}

fn emit_destructure_pattern(pattern: &RustDestructurePattern) -> String {
    match pattern {
        RustDestructurePattern::Name(name) => name.clone(),
        RustDestructurePattern::Ignore => "_".to_string(),
        RustDestructurePattern::Tuple(items) => {
            let inner = items
                .iter()
                .map(emit_destructure_pattern)
                .collect::<Vec<_>>()
                .join(", ");
            format!("({inner})")
        }
        RustDestructurePattern::Slice {
            prefix,
            rest,
            suffix,
        } => {
            let mut items = Vec::new();
            items.extend(prefix.iter().map(emit_destructure_pattern));
            if let Some(name) = rest {
                items.push(format!("{name} @ .."));
            } else if !suffix.is_empty() {
                items.push("..".to_string());
            }
            items.extend(suffix.iter().map(emit_destructure_pattern));
            format!("[{}]", items.join(", "))
        }
    }
}

fn emit_stmt_with_indent(stmt: &RustStmt, out: &mut String, indent: usize) {
    let pad = "    ".repeat(indent);
    match stmt {
        RustStmt::Const(def) => {
            let value = emit_expr(&def.value);
            if should_annotate_local_binding(&def.ty, &def.value) {
                out.push_str(&format!("{pad}let {}: {} = {};\n", def.name, def.ty, value));
            } else {
                out.push_str(&format!("{pad}let {} = {};\n", def.name, value));
            }
        }
        RustStmt::Return(Some(expr)) => {
            out.push_str(&format!("{pad}return {};\n", emit_expr(expr)))
        }
        RustStmt::Return(None) => out.push_str(&format!("{pad}return;\n")),
        RustStmt::DestructureConst { pattern, value } => {
            let binding = emit_destructure_pattern(pattern);
            let value = emit_expr(value);
            if matches!(pattern, RustDestructurePattern::Slice { .. }) {
                out.push_str(&format!(
                    "{pad}let {binding} = {value}.as_slice() else {{ panic!(\"slice destructure mismatch\") }};\n"
                ));
                emit_slice_element_rebinds(pattern, out, indent);
            } else {
                out.push_str(&format!("{pad}let {binding} = {value};\n"));
            }
        }
        RustStmt::Assign { target, op, value } => {
            let op = match op {
                RustAssignOp::Assign => "=",
                RustAssignOp::AddAssign => "+=",
            };
            out.push_str(&format!(
                "{pad}{} {} {};\n",
                emit_assign_target(target),
                op,
                emit_expr(value)
            ));
        }
        RustStmt::If {
            condition,
            then_body,
            else_body,
        } => {
            out.push_str(&format!("{pad}if {} {{\n", emit_condition_expr(condition)));
            for nested in then_body {
                emit_stmt_with_indent(nested, out, indent + 1);
            }
            out.push_str(&format!("{pad}}}"));
            if let Some(else_body) = else_body {
                out.push_str(" else {\n");
                for nested in else_body {
                    emit_stmt_with_indent(nested, out, indent + 1);
                }
                out.push_str(&format!("{pad}}}"));
            }
            out.push('\n');
        }
        RustStmt::While { condition, body } => {
            out.push_str(&format!("{pad}while {} {{\n", emit_condition_expr(condition)));
            for nested in body {
                emit_stmt_with_indent(nested, out, indent + 1);
            }
            out.push_str(&format!("{pad}}}\n"));
        }
        RustStmt::For {
            binding,
            iter,
            body,
        } => {
            if matches!(binding, RustDestructurePattern::Slice { .. }) {
                out.push_str(&format!("{pad}for __item in {} {{\n", emit_expr(iter)));
                out.push_str(&format!(
                    "{pad}    let {} = __item.as_slice() else {{ panic!(\"slice destructure mismatch\") }};\n",
                    emit_destructure_pattern(binding)
                ));
                emit_slice_element_rebinds(binding, out, indent + 1);
                for nested in body {
                    emit_stmt_with_indent(nested, out, indent + 1);
                }
                out.push_str(&format!("{pad}}}\n"));
            } else {
                out.push_str(&format!(
                    "{pad}for {} in {} {{\n",
                    emit_destructure_pattern(binding),
                    emit_expr(iter)
                ));
                for nested in body {
                    emit_stmt_with_indent(nested, out, indent + 1);
                }
                out.push_str(&format!("{pad}}}\n"));
            }
        }
        RustStmt::Loop { body } => {
            out.push_str(&format!("{pad}loop {{\n"));
            for nested in body {
                emit_stmt_with_indent(nested, out, indent + 1);
            }
            out.push_str(&format!("{pad}}}\n"));
        }
        RustStmt::Break => out.push_str(&format!("{pad}break;\n")),
        RustStmt::Continue => out.push_str(&format!("{pad}continue;\n")),
        RustStmt::Raw(code) => {
            out.push_str(&pad);
            out.push_str(code.trim());
            out.push('\n');
        }
        RustStmt::Expr(expr) => out.push_str(&format!("{pad}{};\n", emit_expr(expr))),
    }
}

fn vis(is_public: bool) -> &'static str {
    if is_public { "pub " } else { "" }
}

fn should_annotate_local_binding(ty: &str, value: &RustExpr) -> bool {
    if ty == "_" {
        return false;
    }
    !matches!(value, RustExpr::Closure { .. })
}

fn needs_parens_for_call(expr: &RustExpr) -> bool {
    matches!(
        expr,
        RustExpr::Closure { .. }
            | RustExpr::Match { .. }
            | RustExpr::Unary { .. }
            | RustExpr::Binary { .. }
            | RustExpr::Cast { .. }
            | RustExpr::Range { .. }
    )
}

fn needs_parens_for_borrow(expr: &RustExpr) -> bool {
    matches!(
        expr,
        RustExpr::Closure { .. }
            | RustExpr::Match { .. }
            | RustExpr::Unary { .. }
            | RustExpr::Binary { .. }
            | RustExpr::Cast { .. }
            | RustExpr::Range { .. }
    )
}

fn emit_condition_expr(expr: &RustExpr) -> String {
    let rendered = emit_expr(expr);
    if condition_clause_count(expr) == 1 {
        strip_outer_parens(&rendered).to_string()
    } else {
        rendered
    }
}

fn condition_clause_count(expr: &RustExpr) -> usize {
    match expr {
        RustExpr::Binary { op, left, right } if matches!(op, RustBinaryOp::And | RustBinaryOp::Or) => {
            condition_clause_count(left) + condition_clause_count(right)
        }
        _ => 1,
    }
}

fn strip_outer_parens(text: &str) -> &str {
    let bytes = text.as_bytes();
    if bytes.len() >= 2 && bytes[0] == b'(' && bytes[bytes.len() - 1] == b')' {
        let mut depth = 0usize;
        for (index, ch) in bytes.iter().enumerate() {
            match *ch {
                b'(' => depth += 1,
                b')' => {
                    if depth == 0 {
                        return text;
                    }
                    depth -= 1;
                    if depth == 0 && index + 1 != bytes.len() {
                        return text;
                    }
                }
                _ => {}
            }
        }
        if depth == 0 {
            return &text[1..text.len() - 1];
        }
    }
    text
}

fn collect_mutated_paths_in_stmts(stmts: &[RustStmt]) -> std::collections::HashSet<String> {
    let mut out = std::collections::HashSet::new();
    for stmt in stmts {
        collect_mutated_paths_in_stmt(stmt, &mut out);
    }
    out
}

fn collect_mutated_paths_in_stmt(
    stmt: &RustStmt,
    out: &mut std::collections::HashSet<String>,
) {
    match stmt {
        RustStmt::Assign { target, value, .. } => {
            collect_mutated_paths_in_target(target, out);
            collect_mutated_paths_in_expr(value, out);
        }
        RustStmt::If {
            condition,
            then_body,
            else_body,
            ..
        } => {
            collect_mutated_paths_in_expr(condition, out);
            for stmt in then_body {
                collect_mutated_paths_in_stmt(stmt, out);
            }
            if let Some(else_body) = else_body {
                for stmt in else_body {
                    collect_mutated_paths_in_stmt(stmt, out);
                }
            }
        }
        RustStmt::While { condition, body } => {
            collect_mutated_paths_in_expr(condition, out);
            for stmt in body {
                collect_mutated_paths_in_stmt(stmt, out);
            }
        }
        RustStmt::For { iter, body, .. } => {
            collect_mutated_paths_in_expr(iter, out);
            for stmt in body {
                collect_mutated_paths_in_stmt(stmt, out);
            }
        }
        RustStmt::Loop { body } => {
            for stmt in body {
                collect_mutated_paths_in_stmt(stmt, out);
            }
        }
        RustStmt::Const(def) => collect_mutated_paths_in_expr(&def.value, out),
        RustStmt::DestructureConst { value, .. } => collect_mutated_paths_in_expr(value, out),
        RustStmt::Return(Some(expr)) => collect_mutated_paths_in_expr(expr, out),
        RustStmt::Return(None)
        | RustStmt::Break
        | RustStmt::Continue
        | RustStmt::Raw(_)
         => {}
        RustStmt::Expr(expr) => collect_mutated_paths_in_expr(expr, out),
    }
}

fn collect_mutated_paths_in_target(
    target: &RustAssignTarget,
    out: &mut std::collections::HashSet<String>,
) {
    match target {
        RustAssignTarget::Path(name) => {
            out.insert(name.clone());
        }
        RustAssignTarget::Field { base, .. } => {
            if let Some(name) = root_path_name(base) {
                out.insert(name.to_string());
            }
        }
        RustAssignTarget::Index { base, .. } => {
            if let Some(name) = root_path_name(base) {
                out.insert(name.to_string());
            }
        }
        RustAssignTarget::Tuple(items) => {
            for item in items {
                collect_mutated_paths_in_target(item, out);
            }
        }
    }
}

fn collect_mutated_paths_in_expr(expr: &RustExpr, out: &mut std::collections::HashSet<String>) {
    match expr {
        RustExpr::Call { callee, args } => {
            if let RustExpr::Field { base, field } = callee.as_ref()
                && method_mutates_receiver(field)
                && let Some(name) = root_path_name(base)
            {
                out.insert(name.to_string());
            }
            collect_mutated_paths_in_expr(callee, out);
            for arg in args {
                collect_mutated_paths_in_expr(arg, out);
            }
        }
        RustExpr::MacroCall { args, .. } => {
            for arg in args {
                collect_mutated_paths_in_expr(arg, out);
            }
        }
        RustExpr::Field { base, .. } => collect_mutated_paths_in_expr(base, out),
        RustExpr::Index { base, index } => {
            collect_mutated_paths_in_expr(base, out);
            collect_mutated_paths_in_expr(index, out);
        }
        RustExpr::Match { scrutinee, arms } => {
            collect_mutated_paths_in_expr(scrutinee, out);
            for arm in arms {
                if let Some(guard) = &arm.guard {
                    collect_mutated_paths_in_expr(guard, out);
                }
                collect_mutated_paths_in_expr(&arm.value, out);
            }
        }
        RustExpr::Unary { expr, .. } => collect_mutated_paths_in_expr(expr, out),
        RustExpr::Binary { left, right, .. } => {
            collect_mutated_paths_in_expr(left, out);
            collect_mutated_paths_in_expr(right, out);
        }
        RustExpr::Array(items) | RustExpr::Tuple(items) => {
            for item in items {
                collect_mutated_paths_in_expr(item, out);
            }
        }
        RustExpr::StructLiteral { fields, .. } => {
            for field in fields {
                collect_mutated_paths_in_expr(&field.value, out);
            }
        }
        RustExpr::Closure { body, .. } => {
            for stmt in body {
                collect_mutated_paths_in_stmt(stmt, out);
            }
        }
        RustExpr::Range { start, end, .. } => {
            if let Some(start) = start {
                collect_mutated_paths_in_expr(start, out);
            }
            if let Some(end) = end {
                collect_mutated_paths_in_expr(end, out);
            }
        }
        RustExpr::Try(inner) | RustExpr::Borrow(inner) | RustExpr::Cast { expr: inner, .. } => {
            collect_mutated_paths_in_expr(inner, out)
        }
        RustExpr::Int(_)
        | RustExpr::Bool(_)
        | RustExpr::Char(_)
        | RustExpr::String(_)
        | RustExpr::Path(_) => {}
    }
}

fn method_mutates_receiver(field: &str) -> bool {
    matches!(field, "push")
}

fn emit_char_literal(value: char) -> String {
    match value {
        '\\' => "'\\\\'".to_string(),
        '\'' => "'\\''".to_string(),
        '\n' => "'\\n'".to_string(),
        '\r' => "'\\r'".to_string(),
        '\t' => "'\\t'".to_string(),
        '\0' => "'\\0'".to_string(),
        other => format!("'{other}'"),
    }
}

fn emit_slice_element_rebinds(pattern: &RustDestructurePattern, out: &mut String, indent: usize) {
    let mut names = Vec::new();
    let rest_name = slice_rest_binding_name(pattern);
    collect_slice_element_binding_names(pattern, rest_name, &mut names);
    let pad = "    ".repeat(indent);
    for name in names {
        out.push_str(&format!("{pad}let {name} = (*{name}).clone();\n"));
    }
    if let Some(rest) = rest_name {
        out.push_str(&format!("{pad}let {rest} = {rest}.to_vec();\n"));
    }
}

fn slice_rest_binding_name(pattern: &RustDestructurePattern) -> Option<&str> {
    if let RustDestructurePattern::Slice { rest, .. } = pattern
        && let Some(name) = rest.as_deref()
    {
        return Some(name);
    }
    None
}

fn collect_slice_element_binding_names<'a>(
    pattern: &'a RustDestructurePattern,
    rest_name: Option<&'a str>,
    out: &mut Vec<&'a str>,
) {
    match pattern {
        RustDestructurePattern::Name(name) => {
            if Some(name.as_str()) != rest_name {
                out.push(name.as_str());
            }
        }
        RustDestructurePattern::Ignore => {}
        RustDestructurePattern::Tuple(items) => {
            for item in items {
                collect_slice_element_binding_names(item, rest_name, out);
            }
        }
        RustDestructurePattern::Slice {
            prefix,
            rest,
            suffix,
        } => {
            for item in prefix {
                collect_slice_element_binding_names(item, rest_name, out);
            }
            if let Some(rest_binding) = rest {
                if Some(rest_binding.as_str()) != rest_name {
                    out.push(rest_binding.as_str());
                }
            }
            for item in suffix {
                collect_slice_element_binding_names(item, rest_name, out);
            }
        }
    }
}

fn root_path_name(expr: &RustExpr) -> Option<&str> {
    match expr {
        RustExpr::Path(path) if path.len() == 1 => Some(path[0].as_str()),
        RustExpr::Field { base, .. } => root_path_name(base),
        _ => None,
    }
}
