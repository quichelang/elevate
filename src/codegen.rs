use crate::ir::lowered::{
    RustConst, RustEnum, RustExpr, RustFunction, RustItem, RustModule, RustStatic, RustStruct,
};

pub fn emit_rust_module(module: &RustModule) -> String {
    let mut out = String::new();
    out.push_str("// Generated by elevate compiler skeleton.\n");
    out.push_str("// Do not edit generated output manually.\n\n");
    for item in &module.items {
        match item {
            RustItem::Struct(def) => emit_struct(def, &mut out),
            RustItem::Enum(def) => emit_enum(def, &mut out),
            RustItem::Function(def) => emit_function(def, &mut out),
            RustItem::Const(def) => emit_const(def, &mut out),
            RustItem::Static(def) => emit_static(def, &mut out),
        }
        out.push('\n');
    }
    out
}

fn emit_struct(def: &RustStruct, out: &mut String) {
    out.push_str("#[derive(Debug, Clone)]\n");
    out.push_str(&format!("pub struct {} {{\n", def.name));
    for field in &def.fields {
        out.push_str(&format!("    pub {}: {},\n", field.name, field.ty));
    }
    out.push_str("}\n");
}

fn emit_enum(def: &RustEnum, out: &mut String) {
    out.push_str("#[derive(Debug, Clone)]\n");
    out.push_str(&format!("pub enum {} {{\n", def.name));
    for variant in &def.variants {
        match &variant.payload {
            Some(payload) => out.push_str(&format!("    {}({}),\n", variant.name, payload)),
            None => out.push_str(&format!("    {},\n", variant.name)),
        }
    }
    out.push_str("}\n");
}

fn emit_function(def: &RustFunction, out: &mut String) {
    let params = def
        .params
        .iter()
        .map(|p| format!("{}: {}", p.name, p.ty))
        .collect::<Vec<_>>()
        .join(", ");
    out.push_str(&format!("pub fn {}({})", def.name, params));
    if let Some(ret) = &def.return_type {
        out.push_str(&format!(" -> {ret}"));
    }
    out.push_str(" {\n");
    out.push_str("    todo!(\"function body lowering not implemented yet\");\n");
    out.push_str("}\n");
}

fn emit_const(def: &RustConst, out: &mut String) {
    out.push_str("pub const ");
    out.push_str(&def.name);
    if let Some(ty) = &def.ty {
        out.push_str(&format!(": {ty}"));
    }
    out.push_str(" = ");
    out.push_str(&emit_expr(&def.value));
    out.push_str(";\n");
}

fn emit_static(def: &RustStatic, out: &mut String) {
    out.push_str(&format!(
        "pub static {}: {} = {};\n",
        def.name,
        def.ty,
        emit_expr(&def.value)
    ));
}

fn emit_expr(expr: &RustExpr) -> String {
    match expr {
        RustExpr::Int(value) => value.to_string(),
        RustExpr::Bool(value) => value.to_string(),
        RustExpr::String(value) => format!("{value:?}"),
        RustExpr::Var(name) => name.clone(),
        RustExpr::Call { callee, args } => {
            let args = args.iter().map(emit_expr).collect::<Vec<_>>().join(", ");
            format!("{callee}({args})")
        }
        RustExpr::Field { base, field } => format!("{}.{}", emit_expr(base), field),
    }
}
