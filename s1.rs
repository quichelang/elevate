#![allow(unused_parens)]
#![allow(dropping_copy_types)]
#![allow(dropping_references)]

// Generated by elevate compiler.
// Do not edit generated output manually.

// ownership-note: auto-clone inserted in `test_issue_1_vec_string_index` for `values[_]` of type `String`
// ownership-note: auto-clone inserted in `test_issue_10c_interleaved` for `items` of type `Vec<i64>`
// ownership-note: auto-clone inserted in `test_issue_10d_extend` for `extra` of type `Vec<i64>`
// ownership-note: auto-clone inserted in `keep_even` for `nums` of type `Vec<i64>`
// ownership-note: auto-clone inserted in `test_issue_10f_inplace_transform` for `vals` of type `Vec<i64>`
// ownership-note: auto-clone inserted in `test_issue_10g_pipeline` for `data` of type `Vec<i64>`
// ownership-note: experimental flag enabled: exp_type_system

use std::borrow::{Borrow, BorrowMut};

pub fn test_issue_1_vec_string_index() -> () {
    let values: Vec<String> = vec![::std::string::String::from("a"), ::std::string::String::from("b")];
    let val: String = values[((0 as i64).saturating_abs() as usize)].clone();
    println!("{:?}", val);
}

pub fn add_i32(x: i32, y: i32) -> i32 {
    return (x + y);
}

pub fn test_issue_2_integer_literal_inference() -> () {
    println!("{:?}", add_i32(1, 2));
}

pub fn push_item(nums: &mut Vec<i64>, val: i64) -> () {
    nums.push(val);
}

pub fn pop_last(nums: &mut Vec<i64>) -> () {
    nums.pop();
}

pub fn sum_vec(nums: Vec<i64>) -> i64 {
    let mut result: i64 = 0;
    for n in nums {
        result = (result + n);
    }
    return result;
}

pub fn extend_with(dst: &mut Vec<i64>, src: Vec<i64>) -> () {
    for item in src {
        dst.push(item);
    }
}

pub fn clear_all(nums: &mut Vec<i64>) -> () {
    nums.clear();
}

pub fn double_values(nums: &mut Vec<i64>) -> () {
    let mut i: i64 = 0;
    while i < (nums.len() as i64) {
        nums[((i as i64).saturating_abs() as usize)] = (nums[((i as i64).saturating_abs() as usize)] * 2);
        i = (i + 1);
    }
}

pub fn test_issue_10a_mutate_then_read() -> () {
    let mut numbers: Vec<i64> = vec![1, 2, 3];
    push_item(numbers.borrow_mut(), 42);
    assert_eq!(numbers.len(), 4);
    assert_eq!(sum_vec(numbers), 48);
}

pub fn test_issue_10b_multi_mutate() -> () {
    let mut data: Vec<i64> = vec![10, 20, 30];
    push_item(data.borrow_mut(), 40);
    push_item(data.borrow_mut(), 50);
    pop_last(data.borrow_mut());
    assert_eq!(data.len(), 4);
    assert_eq!(sum_vec(data), 100);
}

pub fn test_issue_10c_interleaved() -> () {
    let mut items: Vec<i64> = vec![1, 2, 3];
    push_item(items.borrow_mut(), 4);
    let mid_sum: i64 = sum_vec(items.clone());
    assert_eq!(mid_sum, 10);
    push_item(items.borrow_mut(), 5);
    assert_eq!(items.len(), 5);
    assert_eq!(sum_vec(items), 15);
}

pub fn test_issue_10d_extend() -> () {
    let mut base: Vec<i64> = vec![1, 2];
    let extra: Vec<i64> = vec![3, 4, 5];
    extend_with(base.borrow_mut(), extra.clone());
    assert_eq!(base.len(), 5);
    assert_eq!(sum_vec(base), 15);
    assert_eq!(extra.len(), 3);
}

pub fn test_issue_10e_loop_accumulate() -> () {
    let mut result: Vec<i64> = vec![];
    let mut i: i64 = 0;
    while i < 5 {
        push_item(result.borrow_mut(), (i * i));
        i = (i + 1);
    }
    assert_eq!(result.len(), 5);
    assert_eq!(sum_vec(result), 30);
}

pub fn keep_even(mut nums: Vec<i64>) -> () {
    let mut temp: Vec<i64> = vec![];
    for n in nums.clone() {
        if (n % 2) == 0 {
            temp.push(n);
        }
    }
    nums.clear();
    extend_with(nums.borrow_mut(), temp);
}

pub fn test_issue_10f_inplace_transform() -> () {
    let mut vals: Vec<i64> = vec![1, 2, 3, 4];
    double_values(vals.borrow_mut());
    assert_eq!(sum_vec(vals.clone()), 20);
    assert_eq!(vals.len(), 4);
}

pub fn test_issue_10g_pipeline() -> () {
    let mut data: Vec<i64> = vec![1, 2, 3, 4, 5, 6];
    double_values(data.borrow_mut());
    keep_even(data.clone());
    assert_eq!(data.len(), 6);
    assert_eq!(sum_vec(data.clone()), 42);
    push_item(data.borrow_mut(), 100);
    assert_eq!(data.len(), 7);
    assert_eq!(sum_vec(data), 142);
}

pub fn add_front(nums: &mut Vec<i64>, val: i64) -> () {
    nums.push(val);
}

pub fn test_issue_10h_two_writers() -> () {
    let mut shared: Vec<i64> = vec![0];
    push_item(shared.borrow_mut(), 1);
    add_front(shared.borrow_mut(), 2);
    push_item(shared.borrow_mut(), 3);
    assert_eq!(shared.len(), 4);
    let total: i64 = sum_vec(shared);
    assert_eq!(total, 6);
}

pub fn test_issue_10i_clear_rebuild() -> () {
    let mut data: Vec<i64> = vec![1, 2, 3];
    clear_all(data.borrow_mut());
    assert_eq!(data.len(), 0);
    push_item(data.borrow_mut(), 10);
    push_item(data.borrow_mut(), 20);
    assert_eq!(data.len(), 2);
    assert_eq!(sum_vec(data), 30);
}

pub fn check_eq<T: PartialEq>(a: T, b: T) -> bool {
    return (a == b);
}

pub fn test_issue_16_generic_bounds() -> () {
    println!("{:?}", check_eq(1, 1));
}

pub fn main() -> () {
    println!("{}", ::std::string::String::from("=== Elevate Issue Regression Tests ==="));
    println!("{}", ::std::string::String::from(""));
    println!("{}", ::std::string::String::from("Issue 1: Vec String Indexing"));
    test_issue_1_vec_string_index();
    println!("{}", ::std::string::String::from("Issue 2: Integer Literal Inference"));
    test_issue_2_integer_literal_inference();
    println!("{}", ::std::string::String::from("Issue 10a: Basic mutate then read"));
    test_issue_10a_mutate_then_read();
    println!("{}", ::std::string::String::from("Issue 10b: Multiple mutating functions"));
    test_issue_10b_multi_mutate();
    println!("{}", ::std::string::String::from("Issue 10c: Interleaved mutate/read"));
    test_issue_10c_interleaved();
    println!("{}", ::std::string::String::from("Issue 10d: Extend one vec from another"));
    test_issue_10d_extend();
    println!("{}", ::std::string::String::from("Issue 10e: Loop accumulate"));
    test_issue_10e_loop_accumulate();
    println!("{}", ::std::string::String::from("Issue 10f: In-place index assignment transform"));
    test_issue_10f_inplace_transform();
    println!("{}", ::std::string::String::from("Issue 10g: Pipeline (mutate, filter, mutate)"));
    test_issue_10g_pipeline();
    println!("{}", ::std::string::String::from("Issue 10h: Two writers, one reader"));
    test_issue_10h_two_writers();
    println!("{}", ::std::string::String::from("Issue 10i: Clear then rebuild"));
    test_issue_10i_clear_rebuild();
    println!("{}", ::std::string::String::from("Issue 16: Generic Trait Bounds"));
    test_issue_16_generic_bounds();
    println!("{}", ::std::string::String::from(""));
    println!("{}", ::std::string::String::from("=== Done ==="));
}

